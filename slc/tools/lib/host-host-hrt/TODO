- add the extended mapping function in the compiler
- fix network.c and remote allocation in tc.c
- fix write_global() in tc.c for network
- fix mem_scatter and mem_gather taking into account that now we have many ranges per TC
- for the mapping function spread, the default place for threads in the new family must be PID (the place
    to which we delegate the new family).

- inspect uses of gettimeofday()


- handle sl_gencallee
- handle should_inline

rename "prev" to "_prev" and the other params of the various flavors of thread functions created by the compiler (foo_begin, foo_middle...)

receive memchunks directly where they have to be placed in memory, avoid buffering

scatter blocks until all confirmations come; if i have multiple scatter's in a create,
        maybe i want to block on the reunion of the 2 sets of confirmations at once...

define an initializer with __attribute__((constructor)) that calls mmap(BIG); free(); 
(or do malloc at the beginning of main()) - to make sure we start
with a non-empty heap, so that a number of mallocs done by libc will work.

take care to close all sockets; in particular the "daemon" one on the primary and secondaries

warning: Using 'getaddrinfo' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking

in write_istruct and read_istruct, the generic version, handle the case where the reader/writer is inexistent (node_index == -1); this will happen for continuation creates, because the parent is inexistent?

replace NODE_INDEX with a function which returns the current node

support continuation creates - careful, the .parent of a TC can't be a dummy, since reading a global
calls get_parent_ident() to find out who is going to write the global...

add a version of send_sctp_msg that send messages with the SCTP_UNORDERED flag, and use it when approprietely 
(e.g. it is _not_ appropriate when writing shareds and when writing to the "done" flag in a FC, because the write
 to done needs to be done after the write to the shareds)


TODO FOR PERFORMANCE:
- remove -pg flag from build of library and program
- make a single call to grab_available_tc() for getting many tc's at the same time when necessary
- inspect uses of gettimeofday()


TO DISCUSS:

- if scatter/gather is not used, a chunk can be modified by the first part of a family through propagate
before being sent to the second chunk (thread 1 is mapped on node 1, thread 2 on node 2, (a,b,c) = (1,0,1)
so each thread gets 2 cells but only updates one, first thread does propagate before second thread
does activate. Is this ok? Should we block propagates somehow creation until all data has been distributed
(how would we know when all activates are done?)
- discuss with Raphael about schemes for distibuting the threads in a fam, and what aditional concurrency some schemes might produce. When assigning multiple chunks to a TC, does a block size != 1 make any sense?


KNOWN ISSUES

- network:
    - in network.c, no_tcp_incoming_sockets needs locking before incrementing and reading it
    - if a header for a memory transfer is not read fully at once from the socket, the code won't work
- tc.c
    - we need to always to map memory chunks in 1MB increments (cause that what the sigsegv handler does)
    - map_fam doesn't take into account the fact that different nodes might have different NO_PROCS

compiler:
  - sl_getma() doesn't work on globals (look in am/visitor.py at do_visit_seta)
          - actually, getma is broken for shareds also; Raphael didn't implement it (as it's not in the am
              visitor). There need to be .cvar for each (mem) argument declaration
