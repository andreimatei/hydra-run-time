remove the use of the first range argument in all the function that currently take it. 
Use the first range from the descriptor, which should always be valid. Pass this first range along
with the stub (if this is done already, write the value to the address of the descriptor and make sure
that the page fault handler maps the page)

Is there a need for a descriptor table in a FC or a TC? We seem to have an issue for shareds (and for
    globals in continuation creates) where a thread allocates a descriptor on the stack and passes it to
    some other thread. At some point, that other thread might want to pull the descriptor (when? currently
    this is not done), but the stack might have been overwritten.
    - if there is a need for a descriptor table, allign and padd descs in a fam context (or TC?)

receive memchunks directly where they have to be placed in memory, avoid buffering

scatter blocks until all confirmations come; if i have multiple scatter's in a create,
        maybe i want to block on the reunion of the 2 sets of confirmations at once...

init main_place_id to -1 (or do smth to force the create in libslmain to be done the local node)

define an initializer with __attribute__((constructor)) that calls mmap(BIG); free(); 
(or do malloc at the beginning of main()) - to make sure we start
with a non-empty heap, so that a number of mallocs done by libc will work.

take care to close all sockets; in particular the "daemon" one on the primary and secondaries

warning: Using 'getaddrinfo' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking

in write_istruct and read_istruct, the generic version, handle the case where the reader/writer is inexistent (node_index == -1); this will happen for continuation creates, because the parent is inexistent?

discuss with Raphael about schemes for distibuting the threads in a fam, and what aditional concurrency some schemes might produce. When assigning multiple chunks to a TC, does a block size != 1 make any sense?

fix atomic_increment_next_tc

replace NODE_INDEX with a function which returns the current node

support continuation creates - careful, the .parent of a TC can't be a dummy, since reading a global
calls get_parent_ident() to find out who is going to write the global...

add a version of send_sctp_msg that send messages with the SCTP_UNORDERED flag, and use it when approprietely 
(e.g. it is _not_ appropriate when writing shareds and when writing to the "done" flag in a FC, because the write
 to done needs to be done after the write to the shareds)



TO DISCUSS:

- if scatter/gather is not used, a chunk can be modified by the first part of a family through propagate
before being sent to the second chunk (thread 1 is mapped on node 1, thread 2 on node 2, (a,b,c) = (1,0,1)
so each thread gets 2 cells but only updates one, first thread does propagate before second thread
does activate. Is this ok? Should we block propagates somehow creation until all data has been distributed
(how would we know when all activates are done?)


KNOWN ISSUES

- network:
    - in network.c, no_tcp_incoming_sockets needs locking before incrementing and reading it
    - if a header for a memory transfer is not read fully at once from the socket, the code won't work
- tc.c
    - we need to always to map memory chunks in 1MB increments (cause that what the sigsegv handler does)

compiler:
  - sl_getma() doesn't work on globals (look in am/visitor.py at do_visit_seta)
          - actually, getma is broken for shareds also; Raphael didn't implement it (as it's not in the am
              visitor). There need to be .cvar for each (mem) argument declaration
