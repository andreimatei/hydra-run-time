#! @BASH@
# -*- mode: shell-script -*-
# slr: This file is part of the SL toolchain.
#
copyright="Copyright (C) 2009,2010 Universiteit van Amsterdam."
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# The complete GNU General Public Licence Notice can be found as the
# `COPYING' file in the root directory.
#
PS4='+ slr($$): '
if test -n "${TRACE:-}"; then set -x; fi
set -eu
python=${PYTHON:-@python@}
slc_helper=${SLC:-@slc_helper@}
sag_helper=${SAG:-@sag_helper@}
slc_libdir=${SLC_LIBDIR:-@slc_libdir@}
slc_datadir=${SLC_DATADIR:-@slc_datadir@}
TMPDIR=${TMPDIR:-/tmp}
KEEP=${KEEP:-}
basename=${0##*/}
version=@slc_version@
bugreports="@bugreports@"

do_usage() {
  cat <<EOF
SL Runner.

The \`slr' utility provides a single interface to run a SVP program
compiled with \`slc'. \`slr' analyses the executable file to determine
how to run the program, and invokes the simulator if needed.

This uses the SL input mechanism described in CSA note [sl3].

Usage: $0 [OPTION] PROGRAM [ARGS]...

Program input options:
  -l                   List variables required as input by the program.

  -dVAR                Define the program input VAR as an empty array.

  -dVAR=..., VAR=...   Define the program input VAR as specified (see 
                       CSA note [sl3] for details).

  -wd FILE             Save the binary input data generated by the -d flags
                       to the specified FILE. 

  -rd FILE             Load the binary input data saved previously with -wd 
                       from FILE. This overrides any -d option.

  -f FILE              Load Fibre I/O data from FILE. The standard input is 
                       used if FILE is set to "-".

  -wf FILE             Save the binary input data generated by -f to the
                       specified FILE.

  -rf FILE             Load the binary input data saved previously with -wx 
                       from FILE. This overrides option -f.  

  -wo                  Stop after reading the input data; do not run the
                       program (useful with -wd and -wf to cache the input
                       before many runs).

Execution selection:
  -c                   Show configuration string embedded in program, if any.

  -x RUNNER            Use the specified RUNNER (use when autodetect fails).

  -b SPEC              Use \`-b SPEC' when invoking the compiler to generate
                       data files.

Microgrid simulation options:
  -m list              List available profiles.

  -m PROFILE           Use the specified simulator PROFILE.

  -Ws,arg              Pass "arg" as extra command line parameter to the 
                       simulator, when the simulator is used.

  -n PLACES            Override the place configuration from the simulator
                       profile.

  -C                   Force COMA memory regardless of the simulator profile.

  -Cc N                Configure N cores per L2 cache in the COMA network. 
                       Implies -C. Overrides profile settings.

  -Cd N                Configure N L2 caches per directory in the COMA network. 
                       Implies -C. Overrides profile settings.

  -X                   Enable graphical output.

  -Xd W,H              Set initial gfx resolution to W(idth)xH(eight). Implies -X.

  -Xs HS,VS            Set initial gfx scaling factors to HSxVS. Implies -X.
  
  -Xr RATE             Set gfx update rate to RATE (cycles/frame). Implies -X.

Debugging options:
  -t                   Trace: print commands before running them.

  -g                   Debug: try to run debugger around the program. Implies -t.

  -gd                  Debug: use debugging when generating data, do not 
                       actually run the program. Implies -t.

  -p DIR               Package: keep all the information and files needed to 
                       re-run the program later. This is stored in a sub-
                       directory of DIR.

Other options:
  -h, --help           Print this help, then exit.

  -v, --version        Print version number, then exit.

Environment variables:
  VERBOSE              If set and not empty, implies option -t.

  DEBUG                If set and not empty, implies option -g.

  DEBUGGER             Command prefix to use as debugger. 
                       Default is \`gdb --args'.

  RUNNER_PREFIX        Command prefix to prepend to the execution
                       command line.

  SIMARGS              Combines with the occurrences of option -Ws on
                       the command line when running the simulator.

  SIMPROFILE           If set and not empty, use as simulation profile
                       unless overridden by -m.

  TMPDIR               If set and not empty, overrides /tmp as the
                       base directory for temporary files.

  KEEP                 If set and not empty, do not delete temporary
                       files after completion.

Examples:

  \$ slr -c a.out 

  Shows the runner string stored in \`a.out'.

  \$ slr fibo.x -dN=15

  Runs \`fibo.x', possibly using the MT simulator, and set program
  input variable N to an array of 1 element with value "15".

  \$ DEBUGGER=valgrind   slr -g  a.out
 
  Runs \`a.out' and wrap the execution with the tool \`valgrind' to
  detect memory corruption issues.

  \$ RUNNER_PREFIX=time  slr a.out

  Runs \`a.out', and report the time to execute the program. This
  yields a finer measurement than \`time slr ...' because the latter
  also includes the time to process the input data.

Report bugs and patches to $bugreports.
EOF
  exit 0
}

do_version() {
  cat <<EOF
$basename $version

$copyright
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Raphael 'kena' Poss.
EOF
  exit 0
}

die() {
  printf '%s: %s\n' "$basename" "$2" >&2
  exit $1
}

# Command line analysis
runner=
prev_arg=
show_embedded=
datatag=
vars=()
program=
query=
rdatafile=
rfdatafile=
wdatafile=
wfdatafile=
preponly=
fibre_in=
SIMGFX=
gfx_scale=
gfx_refresh=
gfx_geometry=
coma_cpc=
coma_cpd=
coma_force=
debug_rec=
ncores_override=
SIMARGS=${SIMARGS:-}
VERBOSE=${VERBOSE:-}
DEBUG=${DEBUG:-}
SIMPROFILE=${SIMPROFILE:-default}
arglist="$*"
for arg in "$@"; do
  # if the previous option needs an argument, assign it
  if test -n "$prev_arg"; then
     eval "$prev_arg=\$arg"
     prev_arg=
     shift
     continue
  fi
  case $arg in
      -x)	prev_arg=runner; shift;;
      -b)       prev_arg=datatag; shift;;
      -c)	show_embedded=1; shift;;
      -t)       VERBOSE=1; shift;;
      -g)	VERBOSE=1; DEBUG=1; shift;;
      -gd)      VERBOSE=1; debug_rec=1; shift;;
      -v|--version)	do_version;;
      -h|--help)	do_usage;;
      -l)  query=1; shift;;
      -n)  prev_arg=ncores_override; shift;;
      -Ws,*)   
	  lowarg=${arg#*,}; 
	  lowarg=${lowarg//,/ } ;
	  SIMARGS+=" $lowarg"
	  shift;;
      -d*=*) var=${arg:2}; vars+=("$var"); shift;;
      -d*) var=${arg:2}; vars+=("$var="); shift;;
      -f)   prev_arg=fibre_in; shift;;
      -rd)  prev_arg=rdatafile; shift;;
      -wd)  prev_arg=wdatafile; shift;;
      -rf)  prev_arg=rfdatafile; shift;;
      -wf)  prev_arg=wfdatafile; shift;;
      -wo)  preponly=1; shift;;
      -m)   prev_arg=SIMPROFILE; shift;;
      -C)   coma_force=1; shift;;
      -Cc)  coma_force=1; prev_arg=coma_cpc; shift;;
      -Cd)  coma_force=1; prev_arg=coma_cpd; shift;;
      -X)   SIMGFX=1; shift;;
      -Xs)  SIMGFX=1; prev_arg=gfx_scale; shift;;
      -Xr)  SIMGFX=1; prev_arg=gfx_refresh; shift;;
      -Xd)  SIMGFX=1; prev_arg=gfx_geometry; shift;;
      -p)   prev_arg=TMPDIR; KEEP=1; shift;;
      --)  break;;
      -*)  die 1 "unrecognized command-line argument: $arg (try -h)";;
      *=*) vars+=("$arg"); shift ;;
      *)   if test -z "$program"; then program=$arg; shift
           else die 1 "unrecognized command-line argument: $arg (try -h)"
	   fi ;;
  esac
done
if test -n "${prev_arg:-}"; then die 1 "argument to \`$arg' is missing"; fi

# if listing profiles, do only that and nothing else
if test "x$SIMPROFILE" = "xlist"; then
  echo "$basename: available profiles:" >&2
  echo "(in $HOME/.mt-profiles)" >&2
  for f in "$HOME/.mt-profiles/"*; do
      if test -r "$f"; then
          b=$(basename "$f")
          if test -L "$f"; then
              (printf '\t%s\t' "$b"; file -h "$f"|cut -d: -f2) >&2
          else
              . "$f"
              printf '\t%s\t %s\n' "$b" "${DESCRIPTION:-(no description)}" >&2
          fi
      fi
  done
  IFS=:
  for d in $slc_datadir; do
    echo "(in $d)" >&2
    for f in "$d/mt-profiles/"*; do
        if test -r "$f"; then
            b=$(basename "$f")
            if test -L "$f"; then
                (printf '\t%s\t' "$b"; file -h "$f"|cut -d: -f2) >&2
            else
                . "$f"
                printf '\t%s\t %s\n' "$b" "${DESCRIPTION:-(no description)}" >&2
            fi
        fi
    done     
  done
  exit 0
fi

if test -n "$VERBOSE"; then
    bn=${0##*/}
    d=$(dirname "$0")
    d=$(cd "$d" && pwd -P)
    echo "command line: $d/$bn $arglist" >&2
    echo "$basename: version: $version" >&2
    echo "$basename: timestamp:" $(TZ=UTC date '+%Y-%m-%d %H:%M:%S (UTC)') >&2
fi

if test -z "$datatag"; then
  # Not specified, find from program
  test -r "$program" || die 1 "file not found or not readable: $program"
  datatag=$(strings "$program"|grep '^slr_datatag:.*:'|tail -n1|cut -d: -f2)
  if test "x$datatag" = "x"; then
    die 1 "can't determine cce tag to recompile"
  fi
fi


# search arggen.sl in the datadirs
saveIFS=$IFS
IFS=:
arggen=
for d in $slc_datadir; do
    if test -r "$d/arggen.c"; then
	arggen=$d/arggen.c
	break
    fi
done
IFS=$saveIFS
if test -z "$arggen"; then
    die 1 "arggen.c not found in $slc_datadir"
fi

# if a slrvars cache file is specified, use it
if test -n "$rdatafile"; then
  if ! test -r "$rdatafile"; then die 1 "$rdatafile: cannot read file"; fi
  if test 0 -lt ${#vars[@]}; then 
    echo "$basename: warning: '-rd $rdatafile' overrides '${vars[*]}'" >&2
  fi
  datafile=$rdatafile
  dodata=
else
  dodata=1
fi

# if a fibre cache file is specified, use it
if test -n "$rfdatafile"; then
  if ! test -r "$rfdatafile"; then die 1 "$rfdatafile: cannot read file"; fi
  if test -n "$fibre_in"; then 
    echo "$basename: warning: '-rf $rfdatafile' overrides '-f $fibre_in'" >&2
  fi
  fdatafile=$rfdatafile
  dofdata=
else
  dofdata=1
fi

# Create a "run package" directory. 
baseout=${program##*/}
SLR_RDIR=$TMPDIR/$baseout.$(date +'%Y%m%d%H%M%S').$$.slr
mkdir -p "$SLR_RDIR"/input
if test -n "$KEEP"; then
    echo "$basename: $SLR_RDIR: will not delete after program termination" >&2
else
    SLR_PID=$$
    (
	    # start watchdog
	PS4='+ slr-wd($$)'
	while true; do 
	    if ! kill -0 $SLR_PID 2>/dev/null; then
		rm -rf "$SLR_RDIR" >/dev/null 2>&1
		exit 0
	    fi
	    sleep 1
	done
    ) & 
fi

# do we need to prepare the slrvars data file?
if test -n "$dodata"; then
    if test -n "$wdatafile"; then
	datafile=$wdatafile
    else    
	datafile="$SLR_RDIR"/input/data
    fi

    test -r "$program" || die 1 "file not found or not readable: $program"
    
    # check program parameters
    strings "$program" | (grep '^slr_arg:'||true) >"$SLR_RDIR"/input/args.spec
    if test -n "$query"; then
	$python "$sag_helper" d list <"$SLR_RDIR"/input/args.spec
	exit 0
    fi

    # does the program take any slr vars?
    if test -s "$SLR_RDIR"/input/args.spec; then

	# prepare C struct with slr var data
	if test -n "$VERBOSE"; then
	    echo "$basename: running: $python $sag_helper d ${vars:+${vars[*]}} <$SLR_RDIR/input/args.spec >$SLR_RDIR/input/data.c" >&2
	fi
	$python "$sag_helper" d ${vars:+"${vars[@]}"} <"$SLR_RDIR"/input/args.spec >"$SLR_RDIR"/input/data.c

	# compile arggen.c with slr var data in C
	mkdir -p "$SLR_RDIR"/slc-rec
	if test -n "$VERBOSE"; then
	    echo "$basename: running: TMPDIR=$SLR_RDIR/slc-rec @BASH@ $slc_helper -b $datatag -o $SLR_RDIR/input/gend.x -I$SLR_RDIR/input $arggen" >&2
	fi
	TMPDIR="$SLR_RDIR"/slc-rec @BASH@ \
            "$slc_helper" -b "$datatag" -o "$SLR_RDIR"/input/gend.x -I"$SLR_RDIR/input" "$arggen"

	# run slr recursively on the arggen binary to dump the data
	mkdir -p "$SLR_RDIR"/slr-rec
	if test -n "$VERBOSE"; then
	    echo "$basename: running: TMPDIR=$SLR_RDIR/slr-rec @BASH@ $0 $SLR_RDIR/input/gend.x >$datafile" >&2
	fi
	if test -n "$debug_rec"; then
	    SLR_RECURSIVE=1 TMPDIR="$SLR_RDIR"/slr-rec @BASH@ "$0" -g -t "$SLR_RDIR"/input/gend.x
	else
	    SLR_RECURSIVE=1 TMPDIR="$SLR_RDIR"/slr-rec @BASH@ "$0" "$SLR_RDIR"/input/gend.x >"$datafile"
	fi
    else
	# just ensure the cache file exists 
	if test -n "$VERBOSE"; then
	    echo "$basename: creating empty data file $datafile" >&2
	fi
        true >"$datafile"
    fi
fi

# do we need to prepare the fibre data file?
if test -n "$dofdata"; then
    if test -n "$wfdatafile"; then
	fdatafile=$wfdatafile
    else    
	fdatafile="$SLR_RDIR"/input/fdata
    fi
    
    # was a Fibre file specified?
    if test -n "$fibre_in"; then
	if test "x$fibre_in" != "x-" -a \! -r "$fibre_in"; then 
	    die 1 "$fibre_in: cannot read file"
	fi

        # transform the Fibre data to a C string definition
	if test -n "$VERBOSE"; then
	    echo "$basename: running: [sed] <$fibre_in |$python $sag_helper f >$SLR_RDIR/input/fdata.c" >&2
	fi
	(if test "x$fibre_in" = "x-"; then cat; else cat "$fibre_in"; fi) | \
	    sed -e 's/\#.*//g;' | \
	    (tr '\t\n' '  ';echo " None") | \
	    sed -e 's/^ *//g;
s/\[[0-9 ,]*: */\[/g;
s/ *\]/\]/g;
s/  */,/g;
s/[dD]/e/g;
s/,$//g' | $python "$sag_helper" f >"$SLR_RDIR"/input/fdata.c
	
	# compile arggen.c with Fibre data in C
	mkdir -p "$SLR_RDIR"/slc-rec
	if test -n "$VERBOSE"; then
	    echo "$basename: running: TMPDIR=$SLR_RDIR/slc-rec @BASH@ $slc_helper -b $datatag -o $SLR_RDIR/input/genf.x -I$SLR_RDIR/input -DFIBRE_DATA=1 $arggen" >&2
	fi
	TMPDIR="$SLR_RDIR"/slc-rec @BASH@ \
	    "$slc_helper" -b "$datatag" -o "$SLR_RDIR"/input/genf.x -I"$SLR_RDIR/input" -DFIBRE_DATA=1 "$arggen"

	# run slr recursively on the arggen binary to dump the data
	mkdir -p "$SLR_RDIR"/slr-rec
	if test -n "$VERBOSE"; then
	    echo "$basename: running: TMPDIR=$SLR_RDIR/slr-rec @BASH@ $0 $SLR_RDIR/input/genf.x >$fdatafile" >&2
	fi
	if test -n "$debug_rec"; then
	    SLR_RECURSIVE=1 TMPDIR="$SLR_RDIR"/slr-rec @BASH@ "$0" -g -t "$SLR_RDIR"/input/genf.x
	else
	    SLR_RECURSIVE=1 TMPDIR="$SLR_RDIR"/slr-rec @BASH@ "$0" "$SLR_RDIR"/input/genf.x >"$fdatafile"
	fi
    else
	# Ensure a tag = -1 for the first Fibre item
	if test -n "$VERBOSE"; then
	    echo "$basename: creating dummy Fibre data file $fdatafile" >&2
	fi
        printf '\xff\xff\xff\xff\xff\xff\xff\xff' >"$fdatafile"
    fi
fi

# debug or cache only?
if test -n "$preponly" -o -n "$debug_rec"; then exit 0; fi

# sanity check on program
if test -z "$program"; then
  die 1 "no program specified"
elif ! test -f "$program"; then
  die 127 "no such file or directory: $program"
elif ! test -x "$program"; then
  die 126 "permission denied: $program"
fi

# detect runner & print string if requested
if test -n "$show_embedded" -o -z "$runner"; then
  tag=$(strings "$program"|grep '^slr_runner:.*:'|tail -n1|cut -d: -f2)
  if test "x$tag" = "x"; then
    if test -n "$show_embedded"; then
       echo "(none found)"
       exit 0    
    fi
  else
    if test -n "$show_embedded"; then
       echo "$tag"
       exit 0    
    fi
  fi
fi

if test -z "$runner"; then
  # Not specified, use tag if found
  if test -n "$tag"; then
     runner=$tag
  else
     die 1 "can't determine runner (try -r)"
  fi
fi

# search the runner in the libdirs
runner_script=
saveIFS=$IFS
IFS=:
for l in $slc_libdir; do
  if test -r "$l/r-$runner.sh"; then
     runner_script=$l/r-$runner.sh
     break
  fi
done
IFS=$saveIFS
if test -z "$runner_script"; then
    die 1 "$runner: cannot find runner script"
fi

# Package program and data files
if test -n "$KEEP"; then
    ln "$program" "$SLR_RDIR/$baseout" 2>/dev/null || cp "$program" "$SLR_RDIR/$baseout"
    if test "x$datafile" != "x$SLR_RDIR/input/data"; then
        ln "$datafile" "$SLR_RDIR/input/data" 2>/dev/null || cp "$datafile" "$SLR_RDIR/input/data"
    fi
    if test "x$fdatafile" != "x$SLR_RDIR/input/fdata"; then
        ln "$fdatafile" "$SLR_RDIR/input/fdata" 2>/dev/null || cp "$fdatafile" "$SLR_RDIR/input/fdata"
    fi
    cd "$SLR_RDIR"
    export SLR_RDIR=.
    datafile=./input/data
    fdatafile=./input/fdata
    program=./$baseout
else
    unset SLR_RDIR
fi

export SIMARGS VERBOSE DEBUG SIMGFX SIMPROFILE
export gfx_scale gfx_geometry gfx_refresh
export coma_cpc coma_cpd coma_force ncores_override

if test -n "$VERBOSE"; then
    echo "$basename: cwd: $PWD" >&2
    echo "$basename: running: @BASH@ $runner_script $program $datafile $fdatafile" >&2
fi
exec @BASH@ "$runner_script" "$program" "$datafile" "$fdatafile"
