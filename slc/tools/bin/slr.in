#! @BASH@
# -*- mode: shell-script -*-
# slr: This file is part of the SL toolchain.
#
copyright="Copyright (C) 2009 Universiteit van Amsterdam."
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# The complete GNU General Public Licence Notice can be found as the
# `COPYING' file in the root directory.
#
# $Id$
#
PS4='+ slr($$): '
if test -n "${TRACE:-}"; then set -x; fi
set -eu
python=${PYTHON:-@python@}
slc_helper=${SLC:-@slc_helper@}
sag_helper=${SAG:-@sag_helper@}
slc_libdir=${SLC_LIBDIR:-@slc_libdir@}
slc_datadir=${SLC_DATADIR:-@slc_datadir@}
TMPDIR=${TMPDIR:-/tmp}
KEEP=${KEEP:-}
basename=${0##*/}
version=@slc_version@
slrev=@slc_revision@
bugreports="@bugreports@"

do_usage() {
  cat <<EOF
SL Runner.

The \`slr' utility provides a single interface to run a SVP program
compiled with \`slc'. \`slr' analyses the executable file to determine
how to run the program, and invokes the simulator if needed.

This uses the SL input mechanism described in CSA note [sl3].

Usage: $0 [OPTION] PROGRAM [ARGS]...

Program input options:
  -l                   List variables required as input by the program.

  -dVAR                Define the program input VAR as an empty array.

  -dVAR=..., VAR=...   Define the program input VAR as specified (see 
                       CSA note [sl3] for details).

  -wd FILE             Save the binary input data generated by the -d flags
                       to the specified FILE. 

  -rd FILE             Load the binary input data saved previously with -wd from
                       FILE. This overrides any -d option.

  -f FILE              Load Fibre I/O data from FILE. The standard input is used
                       if FILE is set to "-".

  -wf FILE             Save the binary input data generated by -f to the
                       specified FILE.

  -rf FILE             Load the binary input data saved previously with -wx from
                       FILE. This overrides option -f.  

  -wo                  Stop after reading the input data; do not run the
                       program (useful with -wd and -wf to cache the input
                       before many runs).

Execution selection:

  -c                   Show configuration string embedded in program, if any.

  -x RUNNER            Use the specified RUNNER (use when autodetect fails).

  -Ws,arg              Pass "arg" as extra command line parameter to the 
                       simulator, when the simulator is used.

  -n PLACES            Use the specified place configuration instead of
                       the default.

Debugging options:
  -t                   Trace: print commands before running them.

  -g                   Debug: try to run debugger around program. Implies -x.

Other options:
  -X                   Enable graphical output.

  -Xd W,H              Set initial gfx resolution to W(idth)xH(eight).

  -Xs HS,VS            Set initial gfx scaling factors to HSxVS.
  
  -Xr RATE             Set gfx refresh rate to RATE.

  -h, --help           Print this help, then exit.

  -v, --version        Print version number, then exit.

Environment variables:
  VERBOSE              If set and not empty, implies option -t.

  DEBUG                If set and not empty, implies option -g.

  DEBUGGER             Command prefix to use as debugger. 
                       Default is \`gdb --args'.

  RUNNER_PREFIX        Command prefix to prepend to the execution
                       command line.

  SIMARGS              Combines with the occurrences of option -Ws on
                       the command line when running the simulator.

  TMPDIR               If set and not empty, overrides /tmp as the
                       base directory for temporary files.

  KEEP                 If set and not empty, do not delete temporary
                       files after completion.

Examples:

  \$ slr -c a.out 

  Shows runner string stored in \`a.out'.

  \$ slr fibo.x -dN=15

  Runs fibo.x, possibly using the MT simulator, and set program input
  variable N to an array of 1 element with value "15".

Report bugs and patches to $bugreports.
EOF
  exit 0
}

do_version() {
  rev='$Rev$'
  rev=${rev#* }
  cat <<EOF
slr $version (rev $slrev/$rev)

$copyright
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Raphael 'kena' Poss.
EOF
  exit 0
}

die() {
  printf '%s: %s\n' "$basename" "$2" >&2
  exit $1
}

# Command line analysis
runner=
prev_arg=
show_embedded=
vars=()
program=
query=
rdatafile=
rfdatafile=
wdatafile=
wfdatafile=
preponly=
fibre_in=
SIMGFX=
gfx_scale=
gfx_refresh=
gfx_geometry=
NCORES=${NCORES:-}
SIMARGS=${SIMARGS:-}
VERBOSE=${VERBOSE:-}
DEBUG=${DEBUG:-}
for arg in "$@"; do
  # if the previous option needs an argument, assign it
  if test -n "$prev_arg"; then
     eval "$prev_arg=\$arg"
     prev_arg=
     shift
     continue
  fi
  case $arg in
      -x)	prev_arg=runner; shift;;
      -c)	show_embedded=1; shift;;
      -t)       VERBOSE=1; shift;;
      -g)	VERBOSE=1; DEBUG=1; shift;;
      -v|--version)	do_version;;
      -h|--help)	do_usage;;
      -l)  query=1; shift;;
      -n)  prev_arg=NCORES; shift;;
      -Ws,*)   
	  lowarg=${arg#*,}; 
	  lowarg=${lowarg//,/ } ;
	  SIMARGS+=" $lowarg"
	  shift;;
      -d*=*) var=${arg:2}; vars+=("$var"); shift;;
      -d*) var=${arg:2}; vars+=("$var="); shift;;
      -f)   prev_arg=fibre_in; shift;;
      -rd)  prev_arg=rdatafile; shift;;
      -wd)  prev_arg=wdatafile; shift;;
      -rf)  prev_arg=rfdatafile; shift;;
      -wf)  prev_arg=wfdatafile; shift;;
      -wo)  preponly=1; shift;;
      -X)   SIMGFX=1; shift;;
      -Xs)  prev_arg=gfx_scale; shift;;
      -Xr)  prev_arg=gfx_refresh; shift;;
      -Xd)  prev_arg=gfx_geometry; shift;;
      --)  break;;
      -*)  die 1 "unrecognized command-line argument: $arg (try -h)";;
      *=*) vars+=("$arg"); shift ;;
      *)   if test -z "$program"; then program=$arg; shift
           else die 1 "unrecognized command-line argument: $arg (try -h)"
	   fi ;;
  esac
done
if test -n "${prev_arg:-}"; then die 1 "argument to \`$arg' is missing"; fi

if test -n "${SIMGFX:-}"; then
  SIMARGS+=" -o GfxEnableOutput=true"
  if test -n "${gfx_scale:-}"; then
    SIMARGS+=" -o GfxHorizScale=${gfx_scale%,*} -o GfxVertScale=${gfx_scale#*,}"
  fi
  if test -n "${gfx_geometry:-}"; then
    SIMARGS+=" -o GfxDisplayWidth=${gfx_geometry%,*} -o GfxDisplayHeight=${gfx_geometry#*,}"
  fi
  if test -n "${gfx_refresh:-}"; then
    SIMARGS+=" -o GfxRefreshRate=$gfx_refresh"
  fi
fi

if test -n "${SLR_RECURSIVE:-}"; then
  NCORES=1
  SIMARGS+=" -q -o NumProcessorsPerFPU=1"
fi 

if test -n "$NCORES" -a -z "${SLR_RECURSIVE:-}"; then
   if ! expr "$NCORES" : '.*,' >/dev/null 2>&1; then
      echo "$basename: warning: \$NCORES and -n are deprecated in favor of dynamic place allocation." >&2  
   fi
else
   NCORES="1,1,1,1,1,1,1,1,2,2,4,4,8,8,16,16,32,32,64,64"
fi

# does the program exist?
if test -z "$program"; then
  die 1 "no program specified"
elif ! test -f "$program"; then
  die 127 "no such file or directory: $program"
fi

# is it executable?
if ! test -x "$program"; then
  die 126 "permission denied: $program"
fi

# detect runner & print string if requested
if test -n "$show_embedded" -o -z "$runner"; then
  tag=$(strings "$program"|grep '^slr_runner:.*:'|tail -n1|cut -d: -f2)
  if test "x$tag" = "x"; then
    if test -n "$show_embedded"; then
       echo "(none found)"
       exit 0    
    fi
  else
    if test -n "$show_embedded"; then
       echo "$tag"
       exit 0    
    fi
  fi
fi

datatag=$(strings "$program"|grep '^slr_datatag:.*:'|tail -n1|cut -d: -f2)
if test "x$datatag" = "x"; then
    die 1 "can't determine cce tag to recompile"
fi

if test -z "$runner"; then
  # Not specified, use tag if found
  if test -n "$tag"; then
     runner=$tag
  else
     die 1 "can't determine runner (try -r)"
  fi
fi

# search the runner in the libdirs
runner_script=
saveIFS=$IFS
IFS=:
for l in $slc_libdir; do
  if test -r "$l/r-$runner.sh"; then
     runner_script=$l/r-$runner.sh
     break
  fi
done
if test -z "$runner_script"; then
    die 1 "$runner: cannot find runner script"
fi

# search arggen.sl in the datadirs
arggen=
for d in $slc_datadir; do
    if test -r "$d/arggen.c"; then
	arggen=$d/arggen.c
	break
    fi
done
IFS=$saveIFS
if test -z "$arggen"; then
    die 1 "arggen.c not found in $slc_datadir"
fi

# if a slrvars cache file is specified, use it
if test -n "$rdatafile"; then
  if ! test -r "$rdatafile"; then die 1 "$rdatafile: cannot read file"; fi
  if test 0 -lt ${#vars[@]}; then 
    echo "$basename: warning: '-rd $rdatafile' overrides '${vars[*]}'" >&2
  fi
  datafile=$rdatafile
  dodata=
else
  dodata=1
fi

# if a fibre cache file is specified, use it
if test -n "$rfdatafile"; then
  if ! test -r "$rfdatafile"; then die 1 "$rfdatafile: cannot read file"; fi
  if test -n "$fibre_in"; then 
    echo "$basename: warning: '-rf $rfdatafile' overrides '-f $fibre_in'" >&2
  fi
  fdatafile=$rfdatafile
  dofdata=
else
  dofdata=1
fi

# if the cache(s) don't yet exist, create a temporary
# directory for the data generation processes. This
# needs to be erased when `slr' and its child processes
# are terminated somehow and KEEP is not set, so start
# a background watchdog for this purpose.
if test -n "$dodata" -o -n "$dofdata"; then
    # build temporary directory
    baseout=${program##*/}
    tmpdir=$(mktemp -d $TMPDIR/"$baseout".slr-XXXXXXXX)
    if test -n "$KEEP"; then
	echo "$basename: $tmpdir: will not delete after program termination" >&2
    else
	SLR_PID=$$
	(
	    # start watchdog
	    PS4='+ slr-wd($$)'
	    while true; do 
		if ! kill -0 $SLR_PID 2>/dev/null; then
		    rm -rf "$tmpdir" >/dev/null 2>&1
		    exit 0
		fi
		sleep 1
	    done
	    ) & 
    fi
fi

# do we need to prepare the slrvars data file?
if test -n "$dodata"; then
    if test -n "$wdatafile"; then
	datafile=$wdatafile
    else    
	datafile="$tmpdir"/data
    fi
    
    # check program parameters
    strings "$program" | (grep '^slr_arg:'||true) >"$tmpdir"/args.spec
    if test -n "$query"; then
	$python "$sag_helper" d list <"$tmpdir"/args.spec
	exit 0
    fi

    # does the program take any slr vars?
    if test -s "$tmpdir"/args.spec; then

	# prepare C struct with slr var data
	if test -n "$VERBOSE"; then
	    echo "$basename: running: $python $sag_helper d ${vars:+${vars[*]}} <$tmpdir/args.spec >$tmpdir/data.c" >&2
	fi
	$python "$sag_helper" d ${vars:+"${vars[@]}"} <"$tmpdir"/args.spec >"$tmpdir"/data.c

	# compile arggen.c with slr var data in C
	mkdir -p "$tmpdir"/slc-rec
	if test -n "$VERBOSE"; then
	    echo "$basename: running: TMPDIR=$tmpdir/slc-rec @BASH@ $slc_helper -b $datatag -o $tmpdir/gen.x -I$tmpdir $arggen" >&2
	fi
	TMPDIR="$tmpdir"/slc-rec @BASH@ "$slc_helper" -b "$datatag" -o "$tmpdir"/gen.x -I"$tmpdir" "$arggen"

	# run slr recursively on the arggen binary to dump the data
	mkdir -p "$tmpdir"/slr-rec
	if test -n "$VERBOSE"; then
	    echo "$basename: running: TMPDIR=$tmpdir/slr-rec @BASH@ $0 $tmpdir/gen.x >$datafile" >&2
	fi
	SLR_RECURSIVE=1 TMPDIR="$tmpdir"/slr-rec @BASH@ "$0" "$tmpdir"/gen.x >"$datafile"
    else
	# just ensure the cache file exists 
        true >"$datafile"
    fi
fi

# do we need to prepare the fibre data file?
if test -n "$dofdata"; then
    if test -n "$wfdatafile"; then
	fdatafile=$wfdatafile
    else    
	fdatafile="$tmpdir"/fdata
    fi
    
    # was a Fibre file specified?
    if test -n "$fibre_in"; then
	if test "x$fibre_in" != "x-" -a \! -r "$fibre_in"; then 
	    die 1 "$fibre_in: cannot read file"
	fi

        # transform the Fibre data to a C string definition
	if test -n "$VERBOSE"; then
	    echo "$basename: running: [sed] <$fibre_in |$python $sag_helper f >$tmpdir/fdata.c" >&2
	fi
	(if test "x$fibre_in" = "x-"; then cat; else cat "$fibre_in"; fi) | \
	    sed -e 's/\#.*//g;' | \
	    (tr '\t\n' '  ';echo " None") | \
	    sed -e 's/^ *//g;
s/\[[0-9 ,]*: */\[/g;
s/ *\]/\]/g;
s/  */,/g;
s/[dD]/e/g;
s/,$//g' | $python "$sag_helper" f >"$tmpdir"/fdata.c
	
	# compile arggen.c with Fibre data in C
	mkdir -p "$tmpdir"/slc-rec
	if test -n "$VERBOSE"; then
	    echo "$basename: running: TMPDIR=$tmpdir/slc-rec @BASH@ $slc_helper -b $datatag -o $tmpdir/gen.x -I$tmpdir -DFIBRE_DATA=1 $arggen" >&2
	fi
	TMPDIR="$tmpdir"/slc-rec @BASH@ \
	    "$slc_helper" -b "$datatag" -o "$tmpdir"/gen.x -I"$tmpdir" -DFIBRE_DATA=1 "$arggen"

	# run slr recursively on the arggen binary to dump the data
	mkdir -p "$tmpdir"/slr-rec
	if test -n "$VERBOSE"; then
	    echo "$basename: running: TMPDIR=$tmpdir/slr-rec @BASH@ $0 $tmpdir/gen.x >$fdatafile" >&2
	fi
	SLR_RECURSIVE=1 TMPDIR="$tmpdir"/slr-rec @BASH@ "$0" "$tmpdir"/gen.x >"$fdatafile"
    else
	# Ensure a tag = -1 for the first Fibre item
        printf '\xff\xff\xff\xff\xff\xff\xff\xff' >"$fdatafile"
    fi
fi

# cache only?
if test -n "$preponly"; then exit 0; fi

export SIMARGS VERBOSE DEBUG NCORES SIMGFX
if test -n "$VERBOSE"; then
    echo "$basename: running: @BASH@ $runner_script $program $datafile $fdatafile" >&2
fi
exec @BASH@ "$runner_script" "$program" "$datafile" "$fdatafile"
