#! /usr/bin/env python
#
# spp: This file is part of the SL toolchain.
#
# Copyright (C) 2009 Universiteit van Amsterdam.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# The complete GNU General Public Licence Notice can be found as the
# `COPYING' file in the root directory.
#
# $Id$
#

import pprint
import sys
import subprocess
import re
import os

def die(msg):
   print >>sys.stderr, "%s:" % sys.argv[0], msg
   sys.exit(1)

def warn(msg):
   print >>sys.stderr, "%s: warning:" % sys.argv[0], msg

class NotFound(Exception):
   pass

class pppalpha(object):

   legacy_fregs = {
      # Scratch registers
      'ft0' : 10,
      'ft1' : 11,
      'ft2' : 12,
      'ft3' : 13,
      'ft4' : 14,
      'ft5' : 15,
      'ft6' : 22,
      'ft7' : 23,
      'ft8' : 24,
      'ft9' : 25,
      'ft10' : 26,
      'ft11' : 27,
      'ft12' : 28,
      'ft13' : 29,
      'ft14' : 30,
      # Return value registers
      'frv' : 0,
      'frv2' : 1,
      # Incoming parameters
      'fa0' : 16,
      'fa1' : 17,
      'fa2' : 18,
      'fa3' : 19,
      'fa4' : 20,
      'fa5' : 21,
      # Call-save registers
      'fs0' : 2,
      'fs1' : 3,
      'fs2' : 4,
      'fs3' : 5,
      'fs4' : 6,
      'fs5' : 7,
      'fs6' : 8,
      'fs7' : 9,
      # Zero 
      'fzero' : 31,
      }

   legacy_regs = {
      # function temporaries
      't0' : 1,
      't1' : 2,
      't2' : 3,
      't3' : 4,
      't4' : 5,
      't5' : 6,
      't6' : 7,
      't7' : 8,
      't8' : 22,
      't9' : 23,
      't10' : 24,
      't11' : 25,
      # assembly scratch
      'at' : 28,
      # return value
      'rv' : 0,
      # incoming parameters
      'a5' : 21,
      'a4' : 20,
      'a3' : 19,
      'a2' : 18,
      'a1' : 17,
      'a0' : 16,
      # procedure function / temporary
      'pv' : 27,
      't12' : 27,
      # Callee-save registers
      's0' : 9,
      's1' : 10,
      's2' : 11,
      's3' : 12,
      's4' : 13,
      's5' : 14,
      # Return address
      'ra' : 26,
      # Frame pointer / callee save
      'fp' : 15,
      's6' : 15,
      # Global pointer
      'gp' : 29,
      # Stack pointer
      'sp' : 30,
      # Zero
      'zero' : 31
      }


    ######################
    # GCC Allocation order
    ######################
    # #define REG_ALLOC_ORDER {
    #    1, 2, 3, 4, 5, 6, 7, 8,      /* nonsaved integer registers */
    #    22, 23, 24, 25, 28,          /* likewise */
    #    0,                           /* likewise, but return value */
    #    21, 20, 19, 18, 17, 16,      /* likewise, but input args */
    #    27,                          /* likewise, but OSF procedure value */
    #    f10, f11, f12, f13, f14, f15,      /* nonsaved floating-point registers */
    #    f22, f23, f24, f25, f26, f27,      /* likewise */
    #    f28, f29, f30,                  /* likewise */
    #    f0, f1,                      /* likewise, but return values */
    #    f21, f20, f19, f18, f17, f16,      /* likewise, but input args */
    #    9, 10, 11, 12, 13, 14,       /* saved integer registers */
    #    26,                          /* return address */
    #    15,                          /* hard frame pointer */
    #    f2, f3, f4, f5, f6, f7,      /* saved floating-point registers */
    #    f8, f9,                      /* likewise */
    #    29, 30, 31, f31               /* gp, sp, ap, sfp */
    # }


   reg_mapping = {
      # Globals
      'g0' : 't11',
      'g1' : 't10',
      'g2' : 't9',
      'g3' : 't8',
      'g4' : 't7',
      'g5' : 't6',
      'g6' : 't5',
      'g7' : 't4',
      'g8' : 't3',
      'g9' : 't2',
      'g10' : 't1',
      'g11' : 't0',

      'gf0' : 'ft11',
      'gf1' : 'ft10',
      'gf2' : 'ft9',
      'gf3' : 'ft8',
      'gf4'  : 'ft7',
      'gf5' : 'ft6',
      'gf6' : 'ft5',
      'gf7' : 'ft4',
      'gf8' : 'ft3',
      'gf9' : 'ft2',
      'gf10' : 'ft1',
      'gf11' : 'ft0',
      
      # Shareds
      's0' : 't0',
      'd0' : 't1',
      's1' : 't2',
      'd1' : 't3',
      's2' : 't4',
      'd2' : 't5',
      's3' : 't6',
      'd3' : 't7',
      's4' : 't8',
      'd4' : 't9',
      's5' : 't10',
      'd5' : 't11',

      'sf0' : 'ft0',
      'df0' : 'ft1',
      'sf1' : 'ft2',
      'df1' : 'ft3',
      'sf2' : 'ft4',
      'df2' : 'ft5',
      'sf3' : 'ft6',
      'df3' : 'ft7',
      'sf4' : 'ft8',
      'df4' : 'ft9',
      'sf5' : 'ft10',
      'df5' : 'ft11',
      
      'lf31' : 'fzero',
      
      'lf0' : 'ft12',
      'lf1' : 'ft13',
      'lf2' : 'ft14',
      'lf3' : 'frv',
      'lf4' : 'frv2',
      'lf5' : 'fa5',
      'lf6' : 'fa4',
      'lf7' : 'fa3',
      'lf8' : 'fa2',
      'lf9' : 'fa1',
      'lf10' : 'fa0',
      'lf11' : 'fs0',
      'lf12' : 'fs1',
      'lf13' : 'fs2',
      'lf14' : 'fs3',
      'lf15' : 'fs4',
      'lf16' : 'fs5',
      'lf17' : 'fs6',
      'lf18' : 'fs7',

      # Special locals
      'l31' : 'zero',
      'l18' : 'sp',
      'l17' : 'gp',
      'l16' : 'fp',
      'l15' : 'ra',
      'l14' : 'pv',
      'l13' : 's5',

      'l12' : 's4',
      'l11' : 's3',
      'l10' : 's2',
      'l9' : 's1',
      'l8' : 's0',
      'l7' : 'a0',
      'l6' : 'a1',
      'l5' : 'a2',
      'l4' : 'a3',
      'l3' : 'a4',
      'l2' : 'a5',
      'l1' : 'rv',
      'l0' : 'at',
      }

   reg_aliases = {
      'tlsp' : 'l18',
      'gp' : 'l17',
      'pv' : 'l14',
      'ra' : 'l15',
      'fp' : 'l16',
      'rv' : 'l1',
      'idx_init' : 'l0',
      'basearg' : 'l1',
      'zero' : 'l31',
      'frv' : 'lf3',
      'fzero' : 'lf31',
      'fbasearg' : 'lf1'
      }

   # Magic numbers
   #iargregs = 6 # 1 reserved for PV
   #fargregs = 4
   iargregs = 11 # 1 reserved for PV
   fargregs = 12
   ilocalregs = 19

   # registers that are known to not be empty
   # when a thread starts: by default, all legacy regs.
   default_presets = set(("$%d" % x for x in xrange(31)))

   jre = re.compile(r'jsr\s|bs?r\s.*!samegp')

   def __init__(self):
      regs = { 
         'i' : { 'l' : [None]*32, 'g' : [None]*32, 's' : [None]*32, 'd' : [None]*32 },
         'f' : { 'l' : [None]*32, 'g' : [None]*32, 's' : [None]*32, 'd' : [None]*32 },
         }
      reg_inv = map(lambda x:[], xrange(32))
      freg_inv = map(lambda x:[], xrange(32))
      aliases = {}

      for r,t in self.reg_mapping.items():
         cat = r[0]
         if r[1] == 'f':
            species = 'f'
            nr = int(r[2:])
            legnr = self.legacy_fregs[t]
            inv_dic = freg_inv
         else:
            species = 'i'
            nr = int(r[1:])
            legnr = self.legacy_regs[t]
            inv_dic = reg_inv
         
         reg = { 'species' : species, 'cat' : cat, 'name' : r, 'legname' : t, 'nr' : nr, 'legnr' : legnr }
         if aliases.has_key(r):
            die("alias %s already defined" % r)
         aliases[r] = reg
         if regs[species][cat][nr] is not None:
            die("register %s already defined" % r)
         regs[species][cat][nr] = reg
         inv_dic[legnr].append(reg)

      for a,k in self.reg_aliases.items():
         if aliases.has_key(a):
            die("alias %s already defined" % a)
         aliases[a] = aliases[k]
      
      # Consistency check
      for i in reg_inv:
         if len(i) == 0:
            die("all legacy integer registers are not used")
      if i in freg_inv:
         if len(i) == 0:
            die("all legacy fp registers are not used")

      self.reg_inv = reg_inv
      self.freg_inv = freg_inv
      self.regs = regs
      self.aliases = aliases

   def mapcall(self, funcname, args):
      dic = { 
         'i' : { 'sh' : [], 'gl' : [] },
         'f' : { 'sh' : [], 'gl' : [] },
         }
      #print args
      for a in args:
         la = a.split(':')
         cat, species, mode, ctype, name = la[:5]
         name = name.strip()
         init = ':'.join(la[5:]).strip()
         if init == "":
            init = None
         dic[species][cat].append({'ctype':ctype, 'name':name, 'init':init, 'glmode':mode})

      # Check if some parameters will use memory passing
      escape = 0      
      if len(dic['f']['sh']) * 2 + len(dic['f']['gl']) > self.fargregs:
         escape = 1
      if len(dic['i']['sh']) * 2 + len(dic['i']['gl']) > (self.iargregs - escape):
         escape = 1

      # Start allocate

      islots_avail = self.iargregs - escape
      fslots_avail = self.fargregs

      # Allocate shareds first
      if len(dic['i']['sh']) * 2 > islots_avail:
         die("function '%s': too many int shareds, cannot pass them via memory yet" % funcname)
      shc = 0
      for s in dic['i']['sh']:
         s['mode'] = 'reg'
         s['regnr'] = shc
         shc += 1
         islots_avail -= 2
      nrishareds = shc

      if len(dic['f']['sh']) > fslots_avail:
         die("function '%s': too many float shareds, cannot pass them via memory yet" % funcname)
      shc = 0
      for s in dic['f']['sh']:
         s['mode'] = 'reg'
         s['regnr'] = shc
         shc += 1
         fslots_avail -= 2
      nrfshareds = shc
   
      # Allocate fp globals
      glc = 0
      memlayout = []
      offset = 0
      for s in dic['f']['gl']:
         if fslots_avail > 0:
            s['mode'] = 'reg'
            s['regnr'] = glc
            glc += 1
            fslots_avail -= 1
         else:
            s['mode'] = 'mem'
            s['offset'] = offset
            offset += 1
            memlayout.append({'cat':'glf','ctype':s['ctype'],'name':s['name'],'init':s['init']})
      nrfglobals = glc

      glc = 0
      for s in dic['i']['gl']:
         if islots_avail > 0:
            s['mode'] = 'reg'
            s['regnr'] = glc
            glc += 1
            islots_avail -= 1
         else:
            s['mode'] = 'mem'
            s['offset'] = offset
            offset += 1
            memlayout.append({'cat':'gli','ctype':s['ctype'],'name':s['name'],'init':s['init']})
      nriglobals = glc

      ret = {}
      if escape == 0:
         ret['gl_mem_offset'] = None
         ret['gl_pv_offset'] = glc
      else:
         warn("function '%s': some arguments are passed via memory" % funcname)
         nriglobals = glc + 1
         ret['gl_mem_offset'] = glc
         ret['gl_pv_offset'] = glc + 1

      nriglobals = nriglobals + 1 # count PV

      ret['nrargregs'] = { 'gli' : nriglobals, 'shi' : nrishareds,
                           'glf' : nrfglobals, 'shf' : nrfshareds }
      ret['args'] = dic
      ret['memlayout'] = memlayout

      #pprint.pprint(ret)

      return ret

   def create(self, funcname, tag, br, *args):
      # DEBUG:
      # print >>sys.stderr, args
      if len(args) == 1 and args[0] == "":
         args = ()

      c = self.mapcall(funcname, args)

      #pprint.pprint(c)

      aliases = self.aliases
      nrargregs = c['nrargregs']

      rregs = []
      wregs = []
      names = []
      glfbase = aliases['fbasearg']['nr']
      shfbase = glfbase + nrargregs['glf']
      glibase = aliases['basearg']['nr']
      shibase = glibase + c['gl_pv_offset'] + 1
      if br == "float":
         brf = shfbase + nrargregs['shf']
         cri = shibase + nrargregs['shi']
      elif br == "int":
         bri = shibase + nrargregs['shi']
         cri = bri + 1
      else: # no break
         cri = shibase + nrargregs['shi']

      print "__sl_allocate(%s, _sl_place, %d, %d, %d, %d);" % \
          (tag, glibase, shibase, glfbase, shfbase)


      for species,d1 in c['args'].items():
         for cat,d2 in d1.items():
            for a in d2:
               name = a['name']
               names.append(name)
               ctype = a['ctype']
               if a['mode'] == 'mem':
                  assert cat == 'gl'
                  print "__sl_declgla_noreg(%s, %s, %s);" % (ctype, name, a['init'])
                  print "m4_pushdef([[__sl_geta_%s]],[[__sl_arg_%s]])m4_dnl" % (name,name)
                  print "m4_pushdef([[__sl_seta_%s]],[[\n#error cannot set global %s\n]])m4_dnl" % (name, name)
               else: # mode: reg
                  regnr = a['regnr']
                  if cat == "sh":
                     if species == "f":
                        reg = "f%d" % aliases['lf%d' % (shfbase + regnr)]['legnr']
                     else:
                        reg = "%d" % aliases['l%d' % (shibase + regnr)]['legnr']
                        
                     if a['init'] is None:
                        print '__sl_declsha_empty(%s, %s, "$%s");' % (ctype, name, reg)
                     else:
                        print '__sl_declsha(%s, %s, "$%s", %s);' % (ctype, name, reg, a['init'])
                     wregs.append('__sl_arg_%s' % name)
                     print 'm4_pushdef([[__sl_geta_%s]],[[__sl_getsha(%s)]])m4_dnl' % (name, name)
                     print 'm4_pushdef([[__sl_seta_%s]],[[__sl_setsha(%s, [[$1]])]])m4_dnl' % (name, name)
                     #print 'm4_pushdef([[__sl_geta_%s]],[[__sl_arg_%s]]) m4_dnl' % (name, name)
                     #print 'm4_pushdef([[__sl_seta_%s]],[[__sl_arg_%s = [[$1]]]]) m4_dnl' % (name, name)
                  else: # cat: gl
                     if species == "f":
                        reg = "f%d" % aliases['lf%d' % (glfbase + regnr)]['legnr']
                     else:
                        reg = "%d" % aliases['l%d' % (glibase + regnr)]['legnr']
                     rregs.append('__sl_arg_%s' % name)
                     print '__sl_declgla(%s, %s, "$%s", %s);' % (ctype, name, reg, a['init'])
                     print 'm4_pushdef([[__sl_geta_%s]],[[__sl_arg_%s]])m4_dnl' % (name, name)
                     print "m4_pushdef([[__sl_seta_%s]],[[\n#error cannot set global %s\n]])m4_dnl" % (name, name)

      pvreg = str(aliases['l%d' % (glibase + c['gl_pv_offset'])]['legnr'])
      print '__sl_declgla(__sl_fptr_t, __fptr%s, "$%s", %s);' % (tag, pvreg, funcname)

      if c['gl_mem_offset'] is not None:
         print "volatile struct __sl_ma_t_%s {" % tag
         for d in c['memlayout']:
            print d['ctype'], d['name'], ';'
         print '} __sl_ma_data_%s;' % tag
         for d in c['memlayout']:
            print '__sl_ma_data_%s.%s = __sl_arg_%s;' % (tag, d['name'], d['name'])

         
         nr = aliases['basearg']['nr'] + c['gl_mem_offset']
         reg = aliases['l%d' % nr]['legnr']
         print "register volatile const struct __sl_ma_t_%s" % tag, \
             '* __restrict__ const __sl_ma_p_%s __asm__("$%d")' % (tag, reg), \
             "= &__sl_ma_data_%s;" % tag

         rregs.append('__sl_ma_p_%s' % tag)

      if br == 'int':
         brreg = aliases['l%d' % bri]['legnr']
         print '__sl_setbreak(%s, %d);' % (tag, bri)
         print '__sl_declbr(%s, long, "$%d");' % (tag, brreg)
         wregs.append('__sl_br_%s' % tag)
      elif br == 'float':
         brreg = aliases['lf%d' % brf]['legnr']
         print '__sl_setbreakf(%s, %d);' % (tag, brf)
         print '__sl_declbr(%s, double, "$f%d");' % (tag, brreg)
         wregs.append('__sl_br_%s' % tag)

      print """
      __sl_setstart(__sl_tag, _sl_start);
      __sl_setlimit(__sl_tag, _sl_limit);
      __sl_setstep(__sl_tag, _sl_step);
      __sl_setblock(__sl_tag, _sl_block);
      """

      crreg = aliases['l%d' % cri]['legnr']
      print '__sl_declsync(%s, "$%d");' % (tag, crreg)
      

      rregs.append('__sl_arg___fptr%s' % tag)
      wregs1 = ['__sl_sync_%s' % tag] + wregs
      wqueue_cre = ", ".join(['"=rf"(%s)' % x for x in wregs1])
      rqueue_cre = ", ".join(['"%d"(%s)' % i for i in enumerate(wregs1)] + ['"rf"(%s)' % x for x in rregs])
      print '__asm__ __volatile__("crei %%0, 0(%%%d)\t# CREATE %s" : %s : %s);' % \
                                (2*len(wregs1)+len(rregs)-1, tag, wqueue_cre, rqueue_cre)

      wqueue_sync = ", ".join(['"=rf"(%s)' % x for x in wregs])
      rqueue_sync = ", ".join(['"%d"(%s)' % i for i in enumerate(wregs)] + ['"rf"(%s)' % x for x in rregs])
      print "m4_define([[__sl_rqueue_sync]],[[%s]])" % rqueue_sync
      print "m4_define([[__sl_nrwrites]],[[%d]])" % len(wregs)
      print "m4_define([[__sl_wqueue_sync]],[[%s]])" % wqueue_sync
      
   def fundef(self, funcname, counter, *args):

      # DEBUG:
      #print >>sys.stderr, args
      if len(args) == 1 and args[0] == "":
         args = ()

      c = self.mapcall(funcname, args)

      mapping = []

      aliases = self.aliases
      print '__sl_prologue(%s, %d, %d, %d, %d, "$%d", %s)' % \
          (funcname, \
              c['nrargregs']['gli'], \
              c['nrargregs']['shi'], \
              c['nrargregs']['glf'], \
              c['nrargregs']['shf'], \
              aliases['idx_init']['legnr'], \
              counter)
      
      # DEBUG:
      #pprint.pprint(c)

      if c['gl_mem_offset'] is not None:
         glreg = 'g%d' % c['gl_mem_offset']
         legnr = aliases[glreg]['legnr']
         mapping.append("%d:%s" % (legnr, glreg))
         print "register const struct {"
         for d in c['memlayout']:
            print d['ctype'], d['name'], ';'
         print '} * __restrict__ const __sl_ma __asm__("$%d");' % legnr
      
      names = []
      for species,d1 in c['args'].items():
         for cat,d2 in d1.items():
            for a in d2:
               name = a['name']
               names.append(name)
               ctype = a['ctype']
               if a['mode'] == 'mem':
                  assert cat == 'gl'
                  print "m4_define([[__sl_getp_%s]],[[(__sl_ma->%s)]])m4_dnl" % (name,name)
                  print "m4_define([[__sl_setp_%s]],[[\n#error cannot set global %s\n]])m4_dnl" % (name, name)
               else: # mode: reg
                  regnr = a['regnr']
                  if cat == "sh":
                     if species == "f":
                        dreg = "df%d" % regnr
                        dlegnr = aliases[dreg]['legnr']
                        sreg = "sf%d" % regnr
                        slegnr = aliases[sreg]['legnr']
                        leg1 = "f%d" % dlegnr
                        leg2 = "f%d" % slegnr
                     else:
                        dreg = "d%d" % regnr
                        dlegnr = aliases[dreg]['legnr']
                        sreg = "s%d" % regnr
                        slegnr = aliases[sreg]['legnr']
                        leg1 = "%d" % dlegnr
                        leg2 = "%d" % slegnr
                     mapping.append("%d:%s" % (dlegnr, dreg))
                     mapping.append("%d:%s" % (slegnr, sreg))
                     
                     print '__sl_declshp(%s, %s, "$%s", "$%s");' % (ctype, name, leg1, leg2)
                     print 'm4_define([[__sl_getp_%s]],[[__sl_getshp(%s)]])m4_dnl' % (name, name)
                     print 'm4_define([[__sl_setp_%s]],[[__sl_setshp(%s, [[$1]])]])m4_dnl' % (name, name)
                  else: # cat: gl
                     if species == "f":
                        reg = "gf%d" % regnr
                        legnr = aliases[reg]['legnr']
                        leg = "f%d" % legnr
                     else:
                        reg = "g%d" % regnr
                        legnr = aliases[reg]['legnr']
                        leg = "%d" % legnr
                     mapping.append("%d:%s" % (legnr, reg))

                     print '__sl_declglp_%s(%s, %s, "$%s");' % (a['glmode'], ctype, name, leg)
                     print 'm4_define([[__sl_getp_%s]],[[__sl_glparm_%s]])m4_dnl' % (name, name)
                     print "m4_define([[__sl_setp_%s]],[[\n#error cannot set global %s\n]])m4_dnl" % (name, name)
      print "m4_define([[__sl_parmnames]],[[%s]])m4_dnl" % ','.join(names)
      print 'm4_define([[__sl_parmspec]],[["%s"]])m4_dnl' % ','.join(mapping)

   def compile(self, arch, compiler, *args):
      """ Run the compiler, adding special flags to fix registers """

      # Add flags to reserve all registers that may be used
      # for shareds, globals and dependents:
      fargs = []
      for (v,l) in [("f",self.freg_inv), ("",self.reg_inv)]:
         fixed = set()
         for rl in l:
            for r in rl:
               if r['cat'] in 'sdg':
                  fixed.add(r['legnr'])
                  
         for r in fixed:
            fargs.append('-ffixed-$%s%d' % (v,r))
      # Indicate to GCC it does not need to save
      # s0 .. s5, fs0 ... fs7 before it uses them:
      for i in xrange(6):
         fargs.append('-fcall-used-$%d' % self.legacy_regs['s%d' % i])
      for i in xrange(8):
         fargs.append('-fcall-used-$f%d' % self.legacy_fregs['fs%d' % i])

      cmd = [compiler] + fargs + list(args) # + ['-fverbose-asm']
      try:
         retcode = subprocess.call(cmd)
         sys.exit(retcode)
      except Exception, e:
         #print >>sys.stderr, sys.argv[0] + ':', ' '.join(cmd)
         print >>sys.stderr, sys.argv[0] + ': %s: %r' % (compiler, e)
         sys.exit(126)



   def makerepl(self, gli, shi, glf, shf):
      """ 
      Create a substitution function suitable for re.sub,
      based on the values given to .registers.
      """

      subst = {}
      regs = self.regs
      for (spec, cat, nr, pref) in [('i','d',shi, ''),('i','s',shi, ''),('i','g',gli, ''),
                                    ('f','d',shf, 'f'),('f','s',shf, 'f'),('f','g',glf, 'f')]:
         for i in xrange(nr):
            r = regs[spec][cat][i]
            key = "%s%d" % (pref,r['legnr'])
            assert not subst.has_key(key)
            subst[key] = '$' + r['name']
      for (spec, pref) in [('i',''),('f','f')]:
         for r in (r for r in regs[spec]['l'] if r is not None):
            key = "%s%d" % (pref,r['legnr'])
            assert not subst.has_key(key)
            subst[key] = '$' + r['name']
      #print "MAKEREPL: ", subst
      def repl(match):
         r = match.group(1)
         #if r == "$31" or r == "$f31":
         #   return r
         return subst.get(r[1:], r)
      
      return repl

   ###
   ### Filtering stages: use Python generators!
   ###

   def reader(self, inname):
      """
      Read a file line by line, produce a generator of lines.
      """
      try:
         inf = file(inname)
      except Exception, e:
         print >>sys.stderr, sys.argv[0] + ':', inname, ': %r' % e
         sys.exit(1)
      for line in (line.rstrip() for line in inf):
         yield line
      inf.close()


   def lexer(self, lines):
      """
      Split code from comments, produce a generator of (code, comment).
      """
      #w = re.compile(r'\s+')
      r = re.compile(r'''((?:"(?:[^\\"]|\\.)*"|'(?:\\.|.)|[^#])*)((#.*)?)''')
      for line in lines:
         m = r.match(line)
         asm = m.group(1)
         comment = m.group(2)
         if comment is None:
            comment = ''
         else:
            comment = comment[1:]
         yield (asm, comment)

   def splitsemi(self, tokens):
      """
      Split lines at semicolons and labels
      """
      r = re.compile(r''';|(?P<rest>(?:"(?:[^\\"]|\\.)*"|'(?:\\.|.)|[^;])+)''')
      relabel = re.compile(r'\S+?:')
      for (asm, comment) in tokens:
         done = False
         for m in r.finditer(asm):
            rest = m.group('rest')
            if rest is not None:
               rest = rest.strip()
               if rest:
                  m = relabel.match(rest)
                  if m is not None:
                     lbl, more = rest.split(':',1)
                     yield (lbl + ':', comment)
                     if more:
                        yield (more.strip(), comment)
                  else:
                     yield (rest, comment)
                  done = True
         if not done and len(comment) > 0:
            yield ('', comment)
                  
         

   def parser(self, tokens):
      """
      Recognize assembly lines, produce a generator of (type, code, comment).
      Type can be "directive", "empty", "label", "other".
      """

      relabel = re.compile(r'\S+?:')
      redir = re.compile(r'\.[a-z]+')

      for (asm, comment) in tokens:
         if not asm:
            yield ('empty', asm, comment)
         elif relabel.match(asm):
            yield ('label', asm, comment)
         elif redir.match(asm):
            yield ('directive', asm, comment)
         else:
            yield ('other', asm, comment)

   def replaceret(self, fundata, items):
      """
      Replace ret by 'end'
      """
      for (type, content, comment) in items:
         if type == 'other' and content.startswith('ret '):
            yield ('other','end','MT: end thread')
         else:
            yield (type, content, comment)
            
   def makedetectload(self, keyname, regname):
      """
      Is there any load of RA or FP from the stack?
      """
      def detectload(fundata, items):
         hasregload = False
         spreg = fundata['specials']['tlsp']
         spec = fundata['specials'][regname]
         r = re.compile(r'ldq\s+\$l%d\s*,\s*\d+\(\$l%d\)' % (spec, spreg))
         for (type, content, comment) in items:
            if type == "other":
               if r.match(content): hasregload = True
            yield (type, content, comment)

         fundata[keyname] = hasregload
      return detectload

   def makecompleteload(self, keyname, regname):
      """
      Force a read on RA and FP before "end" if they were used.
      """
      def completeload(fundata, items):
         hasload = fundata[keyname]
         regnr = fundata['specials'][regname]
         for (type, content, comment) in items:
            if type == 'other' and content == "end":
               if hasload:
                  yield ('other','mov $l%d, $l%d' % (regnr, regnr), 'maybe complete ldq')
            yield (type, content, comment)
      return completeload

   def makeprotectspecial(self, keyname, regname):
      # this transorm appears very late in the chain,
      # and here there is no more split with the prologue.
      # so we have to detect explicitly the prologue boundary again.
      def protectspecial(fundata, items):
         hasload = fundata[keyname]
         regnr = fundata['specials'][regname]
         for (type, content, comment) in items:
            if content.startswith('.prologue') and hasload:
               yield ('other','clr $l%d' % regnr, 'init maybe used')
            yield (type, content, comment)
      return protectspecial

   def munchret(self, fundata, items):
      """
      Remove possible frame adjustment before end thread
      """
      rekill = r'(ld.|ldah|mov|nop|fnop|unop)\s+|(bis|cpys)\s+\$lf?31,\$lf?31,\$lf?31' 
      rekill = re.compile(rekill)

      queue = []
      for (type, content, comment) in items:
         if type == 'other' and content == 'end':
            hello = 1
            qkill = []
            qpreserve = []
            while hello:
               if len(queue) == 0:
                  hello = 0
               else:
                  (t,c,cm) = queue[-1]
                  if t in ['empty','directive']:
                     qpreserve.insert(0, (t,c,cm))
                     queue.pop()
                  elif t == 'other' and \
                         rekill.match(c) and \
                         '$s' not in c and \
                         '$d' not in c and \
                         'SYNC' not in cm:
                     qkill.insert(0,(t,c,cm))
                     queue.pop()
                  else:
                     hello = 0
            for r in qkill:
               queue.append(('empty','','MT: killed cleanup: %s' % r[1]))
            for r in qpreserve:
               queue.append(r)
            queue.append(('other','end','MT: end thread'))
         else:
            queue.append((type, content, comment))

      return queue
            
            

   def detectregs(self, fundata, items):
      """
      Check if GP, SP, PV are used (in case they need to be initialized...)
      """
      jre = self.jre
      use_sp = 0
      spreg = '$%s' % self.reg_aliases['tlsp']
      use_gp = 0
      gpreg = '$%s' % self.reg_aliases['gp']
      #use_pv = 0
      #pvreg = '$%d' % self.legacy_regs['pv']
      for (type, content, comment) in items:
         if type == 'other':
            if spreg in content or jre.match(content):
               use_sp = 1
            if gpreg in content:
               use_gp = 1
            #elif ('jsr' in content) and (pvreg in content):
            #   use_pv = 1
         yield (type, content, comment)
      fundata['use_sp'] = use_sp
      fundata['use_gp'] = use_gp
      #fundata['use_pv'] = use_pv

   def xjoin1(self, fundata, items):
      """
      Rebuild function code back into a single body.
      """
      name = fundata['name']
      for n in fundata['pprologue']:
         yield n
      yield ('label', '$%s..ng:' % name, '')
      for n in fundata['prologue']:
         yield n
      yield ('directive', '.prologue %d' % (fundata['prologuen']), '')
      yield ('empty', '', 'MTREG_SET')
      for n in items:
         yield n

   def xjoin2(self, fundata, items):
      """
      Add function header.
      """
      name = fundata['name']
      regs = fundata['regs']
      yield ('directive', '.globl %s' % name, '')
      yield ('directive', '.ent %s' % name, '')
      yield ('directive', '.registers %d %d %d %d %d %d' % tuple(regs), '')
      yield ('label', '%s:' % name, '')
      if fundata['use_gp']:
         yield ('directive', '.base $l%d' % fundata['specials']['gp'], '')

      p = fundata['presets']
      # print p
      for (type, content, comment) in items:
         if type == 'empty' and comment == 'MTREG_SET':
            if fundata['use_gp']: yield ('empty','','MTREG_SPEC: $l%d' % fundata['specials']['gp'])
            if fundata['use_sp']: yield ('empty','','MTREG_SPEC: $l%d' % fundata['specials']['tlsp'])
            #if fundata['use_pv']: yield ('empty','','MTREG_SPEC: $l%d' % fundata['specials']['pv'])
            yield ('empty', '', 'MTREG_SET: %s' % ','.join(p))
         else:
            yield (type, content, comment)
      yield ('directive', '.end %s' % name, '')
      yield ('directive', '.base $%d' % self.legacy_regs['gp'], '')

   def flattener(self, items):
      """
      Flatten function code back into single stream.
      Produce a generator of (type, code, comment)
      """
      for (type, content, comment) in items:
         if type == "fun":
            for i in content['body']:
               yield i
         else:
            yield (type, content, comment)

   def grouper2(self, items):
      """
      Group function code together.
      Produce a generator of (type, code, comment).
      """

      presets = self.default_presets.copy()
      presets.add("$l0")

      state = 0
      queue = []
      for (type, content, comment) in items:
         if state == 0:
            if content.startswith('.ent'):
               name = content.split(' ',1)[1]
               state = 1
               queue.append((type, content, comment))
               continue
         else:
            queue.append((type, content, comment))
            if not content.startswith('.end'):
               continue
            yield ('fun',{'name':name,'body':queue,'presets':presets},'')
            queue = []
            state = 0
            continue
         for q in queue:
            yield q
         queue = []
         state = 0
         yield (type, content, comment)

   def grouper(self, items):
      """
      Group thread function code together (when applicable).
      Produce a generator of (type, code, comment).

      For functions, emit a single item with type == "fun". In this case
      code is a dictionary with keys:
      - "name" : name of the function
      - "body" : stream of instructions
      """

      state = 0
      queue = []
      presets = set(["$l0"])

      for (type, content, comment) in items:
         if state == 0:
            # expect: .globl __slf_...
            if content.startswith('.globl'):
               name = content.split(' ')[1]
               if name.startswith('__slf_'):
                  state += 1
                  queue.append((type, content, comment))
                  continue
         elif state == 1:
            # expect: .ent __slf_...
            if content.startswith('.ent'):
               maybe_name = content.split(' ')[1]
               if maybe_name == name:
                  state += 1
                  queue.append((type, content, comment))
                  continue
         elif state == 2:
            # expect: stuff, then .end __slf_...
            queue.append((type, content, comment))
            if not content.startswith('.end'):
               continue
            maybe_name = content.split(' ')[1]
            if maybe_name == name:
               state = 0
               yield ('fun',{'name':name[6:],'body':queue, 'specials':{}, 'prologue':[], 'pprologue':[],'prologuen':0,'presets':presets.copy()},'')
               queue = []
               continue

         for q in queue:
            yield q
         queue = []
         state = 0
         yield (type, content, comment)

   def funfilter(self, filter, items):
      for (type, content, comment) in items:
         if type == 'fun':
            #print "XXXXXXXXXXXXXXXXXXXXXX"
            #print filter
            #pprint.pprint(content)
            content['body'] = [x for x in filter(content, content['body'])]
            #pprint.pprint(content)
         yield (type, content, comment)

   def xsplit(self, fundata, items):
      name = fundata['name']
      inprologue = 0
      inpprologue = 0
      for (type, content, comment) in items:
         if content.startswith('.frame ') \
                or content.startswith('.mask ') \
                or content.startswith('.fmask ') \
                or content.startswith('.globl ') \
                or content.startswith('.ent ') \
                or content.startswith('.end '):
            continue
         elif type == 'label' and content == ('$__slf_%s..ng:' % name):
            inpprologue = 0
            inprologue = 1
            continue
         elif inprologue == 1:
            if type == 'label' and content == ('__slf_%s:' % name):
               continue
            elif content.startswith('.prologue'):
               fundata['prologuen'] = int(content.split(' ')[1])
               inprologue = 0
               continue
            fundata['prologue'].append((type, content, comment))
            continue
         elif type == 'label' and content == ('__slf_%s:' % name):
            inpprologue = 1
            continue
         elif inpprologue == 1:
            if type == 'label':
               continue
            fundata['pprologue'].append((type, content, comment))
            continue
         
         yield (type, content, comment)
            

   def regextract(self, fundata, items):
      reregs = re.compile(r'.registers (\d+) (\d+) (\d+) (\d+) (\d+) (\d+)')
      for (type, content, comment) in items:
         m = reregs.match(content)
         if m is not None:
            assert not fundata.has_key('regs')
            fundata['regs'] = [int(x) for x in m.groups()]
            continue

         yield (type, content, comment)
   
   def remdefaults(self, fundata, items):
      resb = re.compile(r'setstart \$l?\d+,\s*0\s*$')
      resl = re.compile(r'setlimit \$l?\d+,\s*1\s*$')
      ress = re.compile(r'setstep \$l?\d+,\s*1\s*$')
      resbl = re.compile(r'setblock \$l?\d+,\s*0\s*$')
      justignored = False
      for (type, content, comment) in items:
         if type == 'other' and \
                (resb.match(content) is not None \
                   or resl.match(content) is not None \
                   or ress.match(content) is not None \
                   or resbl.match(content) is not None):
               # default setting, ignore
            yield ('empty','','MT: "%s" ignored (uses default) # %s' % (content,comment))
            justignored = True
            continue
         elif type == 'other' and justignored and content == 'swch':
            yield ('empty','','MT: swch ignored too # %s' % comment)
            continue
         justignored = False
         yield (type, content, comment)

   def rmdupswch(self, fundata, items):
      seeswch = 0
      for (type, content, comment) in items:
         if type == 'other':
            if content.startswith('swch'):
               if seeswch == 0:
                  seeswch = 1
                  yield (type, content, comment)
            else:
               seeswch = 0
               yield (type, content, comment)
         else:
            yield (type, content, comment)

   def findusedcallregs(self, fundata, items):
      tosave = []
      ftosave = []
      for areg in xrange(0,6):
         legnr = self.legacy_regs['a%d'%areg]
         flegnr = self.legacy_fregs['fa%d'%areg]

         r = self.reg_inv[legnr]
         rf = self.freg_inv[flegnr]

         assert len(r) == 1 and r[0]['cat'] == 'l'
         assert len(rf) == 1 and rf[0]['cat'] == 'l'

         regnr = r[0]['nr'] 
         fregnr = rf[0]['nr'] 

         if fundata['usedregs'][regnr] or fundata['usedfregs'][fregnr]:
            if fundata['usedregs'][regnr]:
               tosave.append(regnr)
            else:
               tosave.append(None)
            if fundata['usedfregs'][fregnr]:
               ftosave.append(fregnr)
            else:
               ftosave.append(None)
         else: 
            break

      # print "FOO", fundata['name'], tosave, ftosave
      fundata['usedcallregs'] = tosave
      fundata['usedcallfregs'] = ftosave
      return items

   def findcallspills(self, fundata, items):
      sp = self.reg_aliases['tlsp']
      respill = r'st[qt]\s+\$l(f?\d+)\s*,\s*\d+\(\$%s\)' % sp
      respill = re.compile(respill)
      tosave = set()
      ftosave = set()
      for (type, content, comment) in items:
         if type == 'other':
            m = respill.match(content)
            if m is not None:
               reg = m.group(1)
               if reg[0] == 'f':
                  ftosave.add(int(reg[1:]))
               else:
                  tosave.add(int(reg))
         yield (type, content, comment)
      fundata['spilledcallregs'] = tosave
      fundata['spilledcallfregs'] = ftosave

   def protectcallregs(self, fundata, items):
      if fundata['hasjumps']:
         init = []
         for r in set(fundata['usedcallregs']): # | fundata['spilledcallregs']:
            if r is not None:
               init.append(('other','clr $l%d' % r, 'init call reg'))
         for r in set(fundata['usedcallfregs']): # | fundata['spilledcallfregs']:
            if r is not None:
               init.append(('other','fclr $lf%d' % r, 'init call freg'))
         fundata['prologue'] = fundata['prologue'] + init
      return items
      

   def rewritejsr(self, fundata, items):
      spreg = int(self.reg_aliases['tlsp'][1:])
      gpreg = int(self.reg_aliases['gp'][1:])
      rareg = int(self.reg_aliases['ra'][1:])
      pvreg = int(self.reg_aliases['pv'][1:])
      rvreg = int(self.reg_aliases['rv'][1:])
      frvreg = int(self.reg_aliases['frv'][2:])

      rvused = fundata['usedregs'][rvreg]
      frvused = fundata['usedfregs'][frvreg]
      usedcallregs = fundata['usedcallregs']
      usedcallfregs = fundata['usedcallfregs']
      protocol = max(len(usedcallregs),len(usedcallfregs))
      # struct { protocol/retval, fptr/fretval, args... }
      gate_struct_size = 8 + 8 + 8 * 2 * protocol 


      jsrre = re.compile('jsr\s+\$l(\d+)\s*,\s*\(\s*\$l(\d+)\s*\)')
      brre = re.compile('br\s+\$l31\s*,\s*(\S+)\s*!samegp')
      bsrre = re.compile('bsr\s+\$l(\d+)\s*,\s*(\S+)\s*!samegp')
      for (type, content, comment) in items:
         if type == "other":
            m = brre.match(content)
            if m is not None:
               # handle "BR"
               lbl = m.group(1)
               yield ('empty','','MT: br call begin: %s' % content)
               yield ('other','lda $l%d, %d($l31)' % (rareg, protocol), 'RA <- nr_call_regs')
               yield ('other','stq $l%d, -8($l%d)' % (rareg, spreg), '.protocol := RA (nr_call_regs)')
               yield ('other','clr $l%d' % rareg, 'use default place')
               yield ('other','allocate $l%d, 0, 0, 0, 0' % rareg, 'RA <- fid')
               yield ('other','ldah $l%d, %s($l%d) !gprelhigh' % (pvreg, lbl, gpreg), 'PV <- target')
               yield ('other','lda $l%d, %s($l%d) !gprellow' % (pvreg, lbl, pvreg), 'PV <- target')
               yield ('other','stq $l%d, -16($l%d)' % (pvreg, spreg), '.fptr := PV')
               arg_offset = -24
               for i in xrange(protocol):
                  if len(usedcallregs)>i and usedcallregs[i] is not None:
                     yield ('other', 'stq $l%d, %d($l%d)' % (usedcallregs[i], arg_offset, spreg), '.arg[%d]' % i)
                  if len(usedcallfregs)>i and usedcallfregs[i] is not None:
                     yield ('other', 'stt $lf%d, %d($l%d)' % (usedcallfregs[i], arg_offset - 8, spreg), 
                            '.farg[%d]' % i)
                  arg_offset -= 16
               yield ('other','ldq $l%d, __sl_callgate($l%d) !literal' % (pvreg, gpreg), 'PV <- callgate')
               yield ('other','setstart $l%d, $l%d' % (rareg, spreg), 'setstart(SP)')
               yield ('other','lda $l%d, 1($l%d)' % (spreg, spreg), 'SP <= SP + 1')
               yield ('other','setlimit $l%d, $l%d' % (rareg, spreg), 'setlimit(SP+1)')
               yield ('other','crei $l%d, 0($l%d)' % (rareg, pvreg), 'start call')
               yield ('other','mov $l%d, $l31' % rareg, 'SYNC: wait for return')
               yield ('other','end','call is end of thread')
               yield ('empty','','MT: br call end')
               continue

            m = bsrre.match(content)
            if m is not None:
               # handle "BSR"
               ra = int(m.group(1))
               lbl = m.group(2)
               yield ('empty','','MT: bsr call begin: %s' % content)
               yield ('other','lda $l%d, %d($l31)' % (ra, protocol), 'RA <- nr_call_regs')
               yield ('other','stq $l%d, -8($l%d)' % (ra, spreg), '.protocol := RA (nr_call_regs)')
               yield ('other','clr $l%d' % ra, 'use default place')
               yield ('other','allocate $l%d, 0, 0, 0, 0' % ra, 'RA <- fid')
               yield ('other','ldah $l%d, %s($l%d) !gprelhigh' % (pvreg, lbl, gpreg), 'PV <- target')
               yield ('other','lda $l%d, %s($l%d) !gprellow' % (pvreg, lbl, pvreg), 'PV <- target')
               yield ('other','stq $l%d, -16($l%d)' % (pvreg, spreg), '.fptr := PV')
               arg_offset = -24
               for i in xrange(protocol):
                  if len(usedcallregs)>i and usedcallregs[i] is not None:
                     yield ('other', 'stq $l%d, %d($l%d)' % (usedcallregs[i], arg_offset, spreg), '.arg[%d]' % i)
                  if len(usedcallfregs)>i and usedcallfregs[i] is not None:
                     yield ('other', 'stt $lf%d, %d($l%d)' % (usedcallfregs[i], arg_offset - 8, spreg), 
                            '.farg[%d]' % i)
                  arg_offset -= 16
               yield ('other','ldq $l%d, __sl_callgate($l%d) !literal' % (pvreg, gpreg), 'PV <- callgate')
               yield ('other','setstart $l%d, $l%d' % (ra, spreg), 'setstart(SP)')
               yield ('other','lda $l%d, 1($l%d)' % (spreg, spreg), 'SP <= SP + 1')
               yield ('other','setlimit $l%d, $l%d' % (ra, spreg), 'setlimit(SP+1)')
               yield ('other','crei $l%d, 0($l%d)' % (ra, pvreg), 'start call')
               yield ('other','lda $l%d, -1($l%d)' % (spreg, spreg), 'SP <= SP - 1')
               yield ('other','mov $l%d, $l31' % ra, 'SYNC: wait for return')
               if rvused:
                  yield ('other','ldq $l%d, -8($l%d)' % (rvreg, spreg), 'restore RV')
                  yield ('other','mov $l%d, $l%d' % (rvreg, rvreg), 'complete memory load')
               if frvused:
                  yield ('other','ldt $lf%d, -16($l%d)' % (frvreg, spreg), 'restore FRV')
                  yield ('other','cpys $lf%d, $lf%d, $lf%d' % (frvreg, frvreg, frvreg), 'complete memory load')
               yield ('empty','','MT: bsr call end')
               continue

            m = jsrre.match(content)
            if m is not None:
               ra = int(m.group(1))
               pv = int(m.group(2))

               # compute structure
               yield ('empty','','MT: jsr call begin: %s' % content)
               yield ('other','lda $l%d, %d($l31)' % (ra, protocol), 'RA <- nr_call_regs')
               yield ('other','stq $l%d, -8($l%d)' % (ra, spreg), '.protocol := RA (nr_call_regs)')
               yield ('other','clr $l%d' % ra, 'use default place')
               yield ('other','allocate $l%d, 0, 0, 0, 0' % ra, 'RA <- fid')
               yield ('other','stq $l%d, -16($l%d)' % (pv, spreg), '.fptr := PV')
               arg_offset = -24
               for i in xrange(protocol):
                  if len(usedcallregs)>i and usedcallregs[i] is not None:
                     yield ('other', 'stq $l%d, %d($l%d)' % (usedcallregs[i], arg_offset, spreg), '.arg[%d]' % i)
                  if len(usedcallfregs)>i and usedcallfregs[i] is not None:
                     yield ('other', 'stt $lf%d, %d($l%d)' % (usedcallfregs[i], arg_offset - 8, spreg), 
                            '.farg[%d]' % i)
                  arg_offset -= 16
               yield ('other','ldq $l%d, __sl_callgate($l%d) !literal' % (pv, gpreg), 'PV <- callgate')
               yield ('other','setstart $l%d, $l%d' % (ra, spreg), 'setstart(SP)')
               yield ('other','lda $l%d, 1($l%d)' % (spreg, spreg), 'SP <= SP + 1')
               yield ('other','setlimit $l%d, $l%d' % (ra, spreg), 'setlimit(SP+1)')
               yield ('other','crei $l%d, 0($l%d)' % (ra, pv), 'start call')
               yield ('other','lda $l%d, -1($l%d)' % (spreg, spreg), 'SP <= SP - 1')
               yield ('other','mov $l%d, $l31' % ra, 'SYNC: wait for return')
               if rvused:
                  yield ('other','ldq $l%d, -8($l%d)' % (rvreg, spreg), 'restore RV')
                  yield ('other','mov $l%d, $l%d' % (rvreg, rvreg), 'complete memory load')
               if frvused:
                  yield ('other','ldt $lf%d, -16($l%d)' % (frvreg, spreg), 'restore FRV')
                  yield ('other','cpys $lf%d, $lf%d, $lf%d' % (frvreg, frvreg, frvreg), 'complete memory load')
               yield ('empty','','MT: jsr call end')
               continue

            if content.startswith('jsr') or (content.startswith('b') and '!samegp' in content):
               die("%s: unsupported call: %s" % (fundata['name'],content))
            
         yield (type, content, comment)

   def findcalls(self, fundata, items):
      jre = self.jre
      hasjumps = False
      for (type, content, comment) in items:
         if type == "other" and jre.match(content):
            hasjumps = True
         yield (type, content, comment)
      fundata['hasjumps'] = hasjumps

   def renameregs(self, fundata, items):
      rd = fundata['regs']
      repl = self.makerepl(rd[0],rd[1],rd[3],rd[4])
      re1reg = re.compile('(\$f?\d+)')
      for (type, content, comment) in items:
         content = re1reg.sub(repl, content)
         comment = re1reg.sub(repl, comment)
         yield (type, content, comment)

   def forcezero(self, items):
      for (type, content, comment) in items:
         content = content.replace('$l31','$31').replace('$lf31','$f31')
         yield (type, content, comment)
         
   def seereg(self, reg, str):
      r = re.compile(r'\$[ld]?f?\d+')
      for m in r.findall(str):
         if m == reg:
            return True
      return False

   def markused(self, fundata, items):
      r1 = re.compile(r'\$l(\d+)')
      r2 = re.compile(r'\$lf(\d+)')
      r3 = re.compile(r'\$g(\d+)')
      r4 = re.compile(r'\$gf(\d+)')
      jre = self.jre
      rmask = [False] * 32
      rfmask = [False] * 32
      rgmask = [False] * 32
      rgfmask = [False] * 32
      spreg = int(self.reg_aliases['tlsp'][1:])
      gpreg = int(self.reg_aliases['gp'][1:])
      rareg = int(self.reg_aliases['ra'][1:])
      for (type, content, comment) in items:
         if type == 'other':
            for rm in r1.finditer(content):
               n = int(rm.group(1))
               rmask[n] = True
            for rm in r2.finditer(content):
               n = int(rm.group(1))
               rfmask[n] = True
            for rm in r3.finditer(content):
               n = int(rm.group(1))
               rgmask[n] = True
            for rm in r4.finditer(content):
               n = int(rm.group(1))
               rgfmask[n] = True
            if jre.match(content):
               # ensure specials are there for calls
               rmask[spreg] = True
               rmask[gpreg] = True
               rmask[rareg] = True
         yield (type, content, comment)
      fundata['usedregs'] = rmask
      fundata['usedfregs'] = rfmask
      fundata['usedgl'] = rgmask
      fundata['usedglf'] = rgfmask


   def makespecialtransform(self, special):
      def dotransform(fundata, items):
         nr = int(self.reg_aliases[special][1:])
         regname = '$l%d' % nr
         rmask = fundata['usedregs']
         dorename = 0
         newnr = nr
         if rmask[nr] == True and False in rmask[:nr]: # self.ilocalregs]:
            freenr = [i for (i,r) in enumerate(rmask) if r == False][0]
            newnr = freenr
            dorename = 1
            newname = '$l%d' % freenr
            rmask[nr] = False
            rmask[freenr] = True
            yield ('empty','','MT: special "%s" renamed from %s to %s' % (special, regname, newname))
         fundata['specials'][special] = newnr
         for (type, content, comment) in items:
            if type == 'other' and dorename == 1:
               content = content.replace(regname, newname)
            yield (type, content, comment)
      return dotransform

   def compress(self, fundata, items):

      regs = fundata['regs']
      rmask = fundata['usedregs']
      rfmask = fundata['usedfregs']
      rgmask = fundata['usedgl']
      rgfmask = fundata['usedglf']

      # Compress integer locals
      lastfound = None
      for i in xrange(30, -1, -1):
         if rmask[i]:
            lastfound = i
            break
      if lastfound is None:
         newnr = 0
      else:
         newnr = lastfound + 1
         
      if newnr < regs[2]:
         yield ('empty','','MT: compressed integer locals from %d to %d' % (regs[2], newnr))
         regs[2] = newnr

      # Compress integer globals
      lastfound = None
      for i in xrange(30, -1, -1):
         if rgmask[i]:
            lastfound = i
            break
      if lastfound is None:
         newnr = 0
      else:
         newnr = lastfound + 1
      if newnr < regs[0]:
         yield ('empty','','MT: compressed integer globals from %d to %d' % (regs[0], newnr))
         regs[0] = newnr

      # Compress FP locals
      lastfound = None
      for i in xrange(30, -1, -1):
         if rfmask[i]:
            lastfound = i
            break
      if lastfound is None:
         newnr = 0
      else:
         newnr = lastfound + 1
      if newnr < regs[5]:
         yield ('empty','','MT: compressed FP locals from %d to %d' % (regs[5], newnr))
         regs[5] = newnr

      # Compress FP globals
      lastfound = None
      for i in xrange(30, -1, -1):
         if rgfmask[i]:
            lastfound = i
            break
      if lastfound is None:
         newnr = 0
      else:
         newnr = lastfound + 1
      if newnr < regs[3]:
         yield ('empty','','MT: compressed FP globals from %d to %d' % (regs[3], newnr))
         regs[3] = newnr

      for (type, content, comment) in items:
         yield (type, content, comment)

   def prunenopend(self, fundata, items):
      queue = []
      for (type, content, comment) in items:
         if type in ['empty','directive']:
            #pprint.pprint((type, content, comment, queue))
            yield (type, content, comment)
            continue
         elif type == 'other':
            #pprint.pprint((type, content, comment, queue))
            if content in ['nop', 'fnop', 'swch']: # and comment != 'MT: branch':
               queue.append((type, content, comment))
               continue
            elif content == 'end':
               if len(queue)>0:
                  yield ('empty','','MT: killed cleanup: %s' % ','.join((c[1] for c in queue)))
               queue = []
         for q in queue:
            yield q
         queue = []
         yield (type, content, comment)

      for q in queue:
         yield q

   def findlabels(self, fundata, items):
      r = re.compile(r'(\$L\d+)')
      deflabels = set()
      uselabels = set()
      for (type, content, comment) in items:
         yield (type, content, comment)
         if type == 'label':
            m = r.match(content)
            if m is not None:
               deflabels.add(m.group(1))
         else:
            for m in r.finditer(content):
               uselabels.add(m.group(1))
      fundata['deflabels'] = deflabels
      fundata['uselabels'] = uselabels
   
   def killunusedlabels(self, fundata, items):
      #print 'def = ', fundata['deflabels']
      #print 'used = ', fundata['uselabels']
      unused = fundata['deflabels'] - fundata['uselabels']
      for (type, content, comment) in items:
         if type == 'label':
            lbl = content[:-1]
            if lbl in unused:
               yield ('empty','','MT: unused label: %s' % lbl)
               continue
         yield (type, content, comment)

   def fixemptyf(self, fundata, items):
      r = re.compile(r'setempty\s(\$lf.*)$')
      for (type, content, comment) in items:
         if type == 'other':
            m = r.match(content)
            if m is not None:
               content = 'setemptyf %s' % m.group(1)
         yield (type, content, comment)

   def protectend(self, fundata, items):
      atlabel = True
      for (type, content, comment) in items:
         if type == 'label': # or (type == 'other' and content == 'swch' and comment == 'MT: branch'):
            atlabel = True
         elif type == 'other':
            if content == 'end' and atlabel:
               yield ('other', 'nop', 'MT: end after label or branch')
            atlabel = False
         yield (type, content, comment)

   def addswchll(self, fundata, items):
      re3way = re.compile(r'\w+\s([^,]+),([^,]+),([^,]+)$')
      re1way = re.compile(r'\w+\s([^,]+)$')
      re2way = re.compile(r'(?:mov|sqrt\S*|cvt\S*|itof\S*|ftoi\S*)\s([^,]+),([^,]+)$')
      rexway = re.compile(r'\w+\s([^,]+),(.*)')
      reld = re.compile(r'(ld[lqts]|ld[bw]u)')
      re3wayll = re.compile(r'(add|sub|mul|div)[fgts]')
      w1way = re.compile(r'(setempty|rpcc|ldfp|f?clr)')
      jre = self.jre

      allregs = set(['$l%d' % x for x in xrange(31 - self.iargregs) if x not in (17, 18)] + \
          ['$lf%d' % x for x in xrange(31 - self.fargregs)] + \
          ['$d%d' % x for x in xrange(self.iargregs / 2)] + \
          ['$df%d' % x for x in xrange(self.fargregs / 2)] + \
          ['$%d' % x for x in xrange(31)])
         
      # initially exclude index
      maybell = allregs.copy()
      for (type, content, comment) in items:
         #print (type,content[:3],comment)
         yield (type, content, comment)
         if type == 'label' or (type == 'other' and jre.match(content)):
            #print "FOO"
            maybell = allregs.copy()

         elif type == 'empty':
            if comment.startswith('MTREG_SET:'):
               hint = set(comment.split(':',1)[1].strip().split(','))
               maybell = maybell - hint
            elif comment.startswith('MTREG_SPEC:'):
               hint = set(comment.split(':',1)[1].strip().split(','))
               maybell = maybell - hint
               allregs = allregs - hint

         elif type == 'other':
            #print "BAR %s :: %s ::" % (content, comment)
            reads = []
            shortwrites = []
            longwrites = []
            done = 0

            # check 3-way insns
            m = re3way.match(content)
            if m is not None and not done:
               r1, r2, r3 = m.groups()
               reads.append(r1)
               reads.append(r2)
               if re3wayll.match(content) is None:
                  shortwrites.append(r3)
               else:
                  longwrites.append(r3)
               done = 1


            # check 1-way insn, 1st is target (e.g. break)
            m = re1way.match(content)
            if m is not None and not done:
               r1 = m.group(1)
               if w1way.match(content) is not None:
                  shortwrites.append(r1)
               else:
                  reads.append(r1)
               done = 1


            # check 2-way insn, second is target (e.g. mov)
            m = re2way.match(content)
            if m is not None and not done:
               r1, r2 = m.groups()
               reads.append(r1)
               if content.startswith('sqrt'):
                  longwrites.append(r2)
               else:
                  shortwrites.append(r2)
               done = 1

       
            # check other insns, assume 1st is target
            m = rexway.match(content)
            if m is not None and not done:
               r1, r2 = m.groups()
               reads.append(r2)

               # Special case for loads from memory:
               m2 = reld.match(content)
               if m2 is not None:
                  longwrites.append(r1)
               elif content.startswith('lda') or content.startswith('ldgp'):
                  #print "FOO"
                  shortwrites.append(r1)
               elif content.startswith('cred') \
                      or content.startswith('crei') \
                      or content.startswith('allocate'):
                  longwrites.append(r1)
                  reads.append(r1)
               else:
                  # insn reads 1st operand, then writes to it
                  reads.append(r1)
                  shortwrites.append(r1)
            
            test = 0
            q = set()

            # if one of the "maybe regs" is read from,
            # assume we are reading result from long latency.
            #print "maybell = %r" % (maybell,)
            #print "reads = %r" % (reads,)
            for rx in maybell:
               for r in reads:
                  if self.seereg(rx,r):
                     test = 1
                     q.add(rx)
            if test == 1:
               yield ('other','swch','MT: long latency: %s' % ','.join(q))

            # all the registers that are "short written"
            # will not cause long latency during next use
            for rx in maybell:
               for r in shortwrites:
                  if self.seereg(rx, r):
                     q.add(rx)

            # remove touched registers from the long latency registers
            for r in q:
               maybell = set((x for x in maybell if x != r))
            # add generated long latency
            for rx in allregs:
               for r in longwrites:
                  if self.seereg(rx, r):
                     maybell.add(rx)
            

   def addswchbr(self, fundata, items):
      rebr = re.compile(r'(f?(br|beq|bne|bge|ble|bgt|blt|blbc)|jsr|ret|jmp|jsr_coroutine)\s')
      for (type, content, comment) in items:
         yield (type, content, comment)
         if rebr.match(content) is not None:
            yield ('other','swch','MT: branch')

   def addswchdep(self, fundata, items):
      redeps = re.compile(r'.*\$df?\d+')
      for (type, content, comment) in items:
         yield (type, content, comment)
         if redeps.match(content) is not None:
            yield ('other','swch','MT: previous insn reads dependent')

   def makespecial(self, fundata, items):
      gli, shi, li, glf, shf, lf = fundata['regs']
      assert gli > 0
      assert li > 3
      pvargreg = gli - 1
      gpreg = li - 2
      spreg = li - 1
      pprologue = fundata['pprologue']
      if fundata['use_gp']:
         # GP needs to be initialized, do it:
         newpprologue = []
         if len(pprologue) == 1:
            # form 1: "ldgp" was used by the compiler
            assert pprologue[0][1].startswith('ldgp')
            newpprologue.append(('other','ldgp $l%d, 0($g%d)' % (gpreg, pvargreg),''))
         else:
            #pprint.pprint(pprologue)
            assert (len(pprologue) == 2 and 'gpdisp' in pprologue[0][1] and 'gpdisp' in pprologue[1][1])
            disp = pprologue[0][1].split('!')[2]
            newpprologue.append(('other','ldah $l%d, 0($g%d) !gpdisp!%s' % (gpreg, pvargreg, disp),''))
            newpprologue.append(('other','lda $l%d, 0($l%d) !gpdisp!%s' % (gpreg, gpreg, disp),''))
         fundata['pprologue'] = newpprologue
      else:
         assert len(pprologue) == 0
      #if fundata['use_pv']:
      #   fundata['prologue'].insert(0, ('other','mov $g%d, $l%d' % (pvargreg, pvreg), 'MT: init PV'))
      if fundata['use_sp'] and spreg != 1:
         fundata['prologue'].insert(0, ('other','ldfp $l%d' % spreg,'MT: init SP'))

      return items

   def avoidframespills(self, fundata, items):
      p = []
      r = re.compile('st. \$lf?\d+')
      for (type, content, comment) in fundata['prologue']:
         if type == 'other' and r.match(content) is not None:
            p.append(('empty','','MT: killed frame spill: %s' % content))
            continue
         p.append((type, content, comment))
      fundata['prologue'] = p
      return items
                   
      

   def killgpreload(self, fundata, items):
      for (type, content, comment) in items:
         if type == 'other' and '!gpdisp!' in content:
            yield ('empty', '', 'MT: killed GP reload: %s' % content)
         else:
            yield (type, content, comment)
   
   def optprologue(self, fundata, items):
      fpreg = '$' + self.reg_aliases['fp']
      rareg = '$' + self.reg_aliases['ra']
      found = False
      for (type, content, comment) in items:
         if type == 'other' and fpreg in content:
            found = True
         yield (type, content, comment)

      # 2009-04-02: beware of not fidgeting too much with FP!
      newprologue = []
      for (type, content, comment) in fundata['prologue']:
         if type == 'other' and (rareg in content or content.startswith("stq %s," % fpreg)):
            newprologue.append(('empty','','MT: FP spill: %s' % content))
         else:
            newprologue.append((type, content,comment))

      if found == True:
         newprologue.insert(0,('other','mov $l31, %s' % fpreg,'MT: init FP'))
      fundata['prologue'] = newprologue

   def printer(self, items):
      for (type, content, comment) in items:
         if comment:
            tail = "#%s" % comment
         else:
            tail = ""
         if type == "label":
            head = '%-40s\t' % content
         elif content:
            head = '\t%-32s\t' % content
         else:
            head = ''
         yield '%s%s\n' % (head, tail)

   def filter(self, output, *inputs):
      """ 
      Transform compiler output (invalid, raw asm) to good-looking
      .s files that can be assembled by an external assembler.
      """
      try:
         outf = file(output, "w")
      except Exception, e:
         print >>sys.stderr, sys.argv[0] + ':', output, ': %r' % e
         sys.exit(1)

      for inname in inputs:
         lines = self.reader(inname)
         tokens = self.lexer(lines)
         tokens = self.splitsemi(tokens)
         items = self.parser(tokens)
         groups = self.grouper(items)
         groups = self.funfilter(self.regextract, groups)
         groups = self.funfilter(self.renameregs, groups)
         groups = self.funfilter(self.detectregs, groups)
         groups = self.funfilter(self.replaceret, groups)
         groups = self.funfilter(self.munchret, groups)

         groups = self.funfilter(self.xsplit, groups)

         groups = self.funfilter(self.avoidframespills, groups)
         groups = self.funfilter(self.makespecial, groups)
         groups = self.funfilter(self.killgpreload, groups)
         groups = self.funfilter(self.optprologue, groups)

         groups = self.funfilter(self.markused, groups)
         groups = self.funfilter(self.findcalls, groups)
         groups = self.funfilter(self.findusedcallregs, groups)
         # groups = self.funfilter(self.findcallspills, groups)
         groups = self.funfilter(self.protectcallregs, groups)
         groups = self.funfilter(self.rewritejsr, groups)

         groups = self.funfilter(self.xjoin1, groups)

         groups = self.funfilter(self.markused, groups)
         groups = self.funfilter(self.makespecialtransform('gp'), groups)
         groups = self.funfilter(self.makespecialtransform('tlsp'), groups)
         groups = self.funfilter(self.makespecialtransform('fp'), groups)
         groups = self.funfilter(self.makespecialtransform('ra'), groups)
         groups = self.funfilter(self.makespecialtransform('pv'), groups)
         #groups = self.funfilter(self.makespecialtransform('rv'), groups)
         groups = self.funfilter(self.compress, groups)
         groups = self.funfilter(self.xjoin2, groups)
         groups = self.funfilter(self.munchret, groups)
         groups = self.funfilter(self.makedetectload('hasraload','ra'), groups)
         groups = self.funfilter(self.makecompleteload('hasraload','ra'), groups)
         groups = self.funfilter(self.makeprotectspecial('hasraload', 'ra'), groups)
         groups = self.funfilter(self.makedetectload('hasfpload','fp'), groups)
         groups = self.funfilter(self.makecompleteload('hasfpload','fp'), groups)
         items = self.flattener(groups)
         items = self.forcezero(items)
         lines = self.printer(items)
         for line in lines:
            # print "YOO:", line,
            outf.write(line)
      outf.close()

   def filter2(self, flags, output, *inputs):
      """
      Enhance already valid assembly.
      """

      stages = ['remdefaults', 'findlabels', 'killunusedlabels',
                'addswchll', 'addswchbr', 'rmdupswch',
                'prunenopend', 'protectend', 'fixemptyf']
      # parse flags
      opts = dict(((s,1) for s in stages))
      flags = flags.split(':',1)[1]
      if len(flags) > 0:
         for f in flags.split(' '):
            if f == 'no-all' or f == 'none':
               for k in opts.keys(): opts[k] = 0
            elif f == 'all':
               for k in opts.keys(): opts[k] = 1
            else:
               if f.startswith('no-'):
                  name = f[3:]
                  value = 0
               else:
                  name = f
                  value = 1
               if name not in stages:
                  die('error: unrecognized command line option "-f%s-%s"' %
                      (value and "asmopt" or "no-asmopt", name))
               opts[name] = value

      verbose = (os.getenv('SLC_VERBOSE','no') == 'yes')

      if verbose: print >>sys.stderr, 'asmopts: %r' % opts

      try:
         outf = file(output, "w")
      except Exception, e:
         print >>sys.stderr, sys.argv[0] + ':', output, ': %r' % e
         sys.exit(1)

      for inname in inputs:
         lines = self.reader(inname)
         tokens = self.lexer(lines)
         tokens = self.splitsemi(tokens)
         items = self.parser(tokens)
         groups = self.grouper2(items)
         for k in stages:
            if opts[k]:
               #if verbose: print >>sys.stderr, 'stage: %s' % k
               groups = self.funfilter(getattr(self, k), groups)
         items = self.flattener(groups)
         items = self.forcezero(items)
         lines = self.printer(items)
         for line in lines:
            # print "YOO:", line,
            outf.write(line)
      outf.close()

class utc0(pppalpha):
   pass

if __name__ == "__main__":
   module = sys.argv[1]
   function = sys.argv[2]
   rest = sys.argv[3:]
   c = eval(module + "()")
   getattr(c,function)(*rest)

