#! /usr/bin/env python
#
# spr: This file is part of the SL toolchain.
#
import sys
import re
import pprint

ws = r'(?:\s|#line\s[^\n]*\n)*'

re_ws = re.compile('^' + ws + '$', re.S)
re_identifier = re.compile('^' + ws + r'([a-zA-Z_][a-zA-Z0-9_]*)' + ws + '$', re.S)

re_endswithline = re.compile(r'.*#line\s+\d+(?:\s+"[^"]*")?\s+$', re.S)

def die(msg):
   print >>sys.stderr, "%s:" % sys.argv[0], msg
   sys.exit(1)

#### Abstract syntax tree ####

def extract_id(context, name):
      m = re_identifier.match(name)
      if m is None:
            choke(context, "invalid identifier: '%s'" % name)
      return m.group(1)

def makeloc(locinfo):
      f, l = locinfo.rsplit(':', 1)
      return (int(l), f)

class Item(object):
      def __init__(self):
            self.loc = None
            self.loc_end = None
            self.repr = None
     
      def set_loc(self, loc):
            if type(loc) == type(''): loc = makeloc(loc)
            self.loc = loc
      def set_loc_end(self, loc_end):
            if type(loc_end) == type(''): loc_end = makeloc(loc_end)
            self.loc_end = loc_end

class Opaque(Item):
      def __init__(self):
            Item.__init__(self)
            self.text = None
      def set_text(self, text):
            self.text = text

      def accept(self, v):
            return v.dispatch().visit_opaque(self)

      def __repr__(self):
            return '<Opaque@0x%x: %r>' % (id(self), self.text)

# class Alternate(Item):
#       def __init__(self):
#             self.parts = {}

#       def set_part(self, name, item): 
#             self.parts[name] = item

#       def accept(self, v):
#             newd = {}
#             for (name, item) in self.parts.iteritems():
#                   n = v.dispatch_alternate(name, item)
#                   if n is not None:
#                         newd[name] = n
#             self.parts = newd

class Block(Item):
      def __init__(self):
            Item.__init__(self)
            self.items = []
            self.indexname = None
      
      def add_item(self, item):
            self.items.append(item)

      def set_indexname(self, name):
            self.indexname = extract_id(self, name)

      def accept(self, v):
            return v.dispatch().visit_block(self)

class Program(Block):
      def accept(self, v):
            return v.dispatch().visit_program(self)

class FunDecl(Item):
      def __init__(self):
            Item.__init__(self)
            self.name = None
            self.parms = []

      def set_name(self, name):
            self.name = extract_id(self, name)

      def add_parm(self, parm):
            self.parms.append(parm)
      
      def accept(self, v):
            return v.dispatch().visit_fundecl(self)

class FunDef(FunDecl):
      def __init__(self):
            FunDecl.__init__(self)
            self.body = None

      def set_body(self, body):
            self.body = body

      def accept(self, v):
            return v.dispatch().visit_fundef(self)

class ArgParam(Item):
      def __init__(self):
            Item.__init__(self)
            self.name = None
            self.ctype = None
            self.type = None

      def set_type(self, type):
            self.type = type
      def set_ctype(self, ctype):
            self.ctype = ctype
      def set_name(self, name):
            self.name = extract_id(self, name)

class FunParam(ArgParam):
      def accept(self, v):
            return v.dispatch().visit_funparm(self)

class CreateArg(ArgParam):
      def __init__(self):
            self.init = None

      def set_init(self, init): self.init = init

      def accept(self, v):
            return v.dispatch().visit_createarg(self)

class VarUse(Item):
      def __init__(self):
            Item.__init__(self)
            self.name = None
      def set_name(self, name):
            self.name = extract_id(self, name)

class VarSet(VarUse):
      def __init__(self):
            VarUse.__init__(self)
            self.rhs = None
      def set_rhs(self, rhs):
            self.rhs = rhs

class GetParam(VarUse): 
      def accept(self, v): return v.dispatch().visit_getp(self)

class GetArg(VarUse): 
      def accept(self, v): return v.dispatch().visit_geta(self)

class SetParam(VarSet): 
      def accept(self, v): return v.dispatch().visit_setp(self)

class SetArg(VarSet): 
      def accept(self, v): return v.dispatch().visit_seta(self)

class Create(Item):
      def __init__(self):
            Item.__init__(self)
            self.label = None
            self.place = None
            self.start = None
            self.step = None
            self.limit = None
            self.block = None
            self.id = None
            self.sync_type = None
            self.body = None
            self.result_lvalue = None
            self.fid_lvalue = None
            self.fun = None
            self.args = []
      def add_arg(self, arg): self.args.append(arg)
      def set_label(self, label): self.label = extract_id(self, label)
      def set_place(self, place): self.place = place
      def set_start(self, start): self.start = start
      def set_step(self, step): self.step = step
      def set_limit(self, limit): self.limit = limit
      def set_block(self, block): self.block = block
      def set_id(self, id): self.id = id
      def set_sync_type(self, sync_type): self.sync_type = sync_type
      def set_body(self, body): self.body = body
      def set_result_lvalue(self, lvalue): self.result_lvalue = lvalue
      def set_fid_lvalue(self, lvalue): self.fid_lvalue = lvalue
      def set_fun(self, fun):
            if len(fun.items) == 1:
                  m = re_identifier.match(fun.items[0].text)
                  if m is not None:
                        self.fun = m.group(1)
                        return
            self.fun = fun
      def funIsIdentifier(self):
            return type(self.fun) == type('')

      def accept(self, v):
            return v.dispatch().visit_create(self)

class EndThread(Item):
      def accept(self, v):
            return v.dispatch().visit_end_thread(self)

class Break(Item):
      def accept(self, v):
            return v.dispatch().visit_break(self)

#### Parser ####


def cleanup(source):
      # remove extra whitespace
      if type(source) == type([]):
            return [x for x in (cleanup(y) for y in source) if len(x) != 0]
      elif type(source) == type(""):
            #if re_endswithline.match(source) is not None:
            #      return source.lstrip()
            return source.strip(' \t')
      elif type(source) == type({}):
            return dict( ( (k,cleanup(v)) for (k,v) in source.iteritems() ) )
      else: 
            raise RuntimeError, "unknown item type: %r" % source


def choke(item, msg, warning = False):
      if type(item) == type({}) and item.has_key('loc'):
            item = item['loc']
      elif hasattr(item, 'loc'):
            item = getattr(item, 'loc')
           
      if type(item) == type(()) and len(item) == 2:
            item = '%s:%d' % (item[1], item[0])

      if type(item) == type(''):
            print >>sys.stderr, '%s:' % item,

      print >>sys.stderr, msg
      if not warning:
            sys.exit(1)

def warn(item, msg):
      return choke(item, msg, warning = True)

def unexpected(item):
      choke(item, "unexpected construct '%s'" % item.get('type','unknown'))

def make_opaque(item):
      c = Opaque()
      c.set_text(item)
      return c

def isemptyblock(item):
      return item == [] or (len(item) == 1 and len(item[0]) == 0)

def parse_varuse(varuse, item):
      varuse.set_loc(item['loc'])
      varuse.set_name(item['name'])
      if item.has_key('body'):
            varuse.set_rhs(parse_block(item['body'], False))
      return varuse

def parse_create(item):
      c = Create()
      c.set_loc(item['loc'])
      c.set_loc_end(item['loc_end'])
      c.set_label(item['lbl'])
      c.set_place(parse_block(item['place'], False))
      c.set_start(parse_block(item['start'], False))
      c.set_limit(parse_block(item['limit'], False))
      c.set_step(parse_block(item['step'], False))
      c.set_block(parse_block(item['block'], False))
      c.set_sync_type(item['sync'])
      c.set_fun(parse_block(item['fun'], False))
      for p in item['args']:
            c.add_arg(parse_argparm(CreateArg(), 'arg', p))
      c.set_body(parse_block(item['body'], False))
      if item.has_key('result') and item['result']:
            c.set_result_lvalue(parse_block(item['result'], False))
      if item.has_key('fid') and item['fid']:
            c.set_fid_lvalue(parse_block(item['fid'], False))
      return c

def parse_block(items, allow_index = False):
      if len(items) == 0:
            return None
      b = Block()
      for item in items:
            if type(item) == type({}):
                  t = item['type']
                  if t == 'indexdecl' and allow_index: b.set_indexname(item['name'])
                  elif t == 'getp': b.add_item(parse_varuse(GetParam(), item))
                  elif t == 'setp': b.add_item(parse_varuse(SetParam(), item))
                  elif t == 'geta': b.add_item(parse_varuse(GetArg(), item))
                  elif t == 'seta': b.add_item(parse_varuse(SetArg(), item))
                  elif t == 'create': b.add_item(parse_create(item))
                  elif t == 'break': b.add_item(parse_break(item))
                  elif t == 'end_thread': b.add_item(parse_end_thread(item))
                  else: unexpected(item)
                        
            else: b.add_item(make_opaque(item))
      return b

def parse_argparm(p, cat, item):
      if not item['type'].endswith(cat):
            unexpected(item)
      p.set_loc(item['loc'])
      p.set_type(item['type'])
      p.set_ctype(item['ctype'])
      p.set_name(item['name'])
      if item.has_key('init'):
         p.set_init(parse_block(item['init'], False))
      return p            

def parse_break(item):
      b = Break()
      b.set_loc(item['loc'])
      return b

def parse_end_thread(item):
      e = EndThread()
      e.set_loc(item['loc'])
      return e

def parse_fundecl(item):
      d = FunDecl()
      d.set_loc(item['loc'])
      d.set_name(item['name'])
      for p in item['params']:
            d.add_parm(parse_argparm(FunParam(), 'parm', p))
      return d

def parse_fundef(item):
      d = FunDef()
      d.set_loc(item['loc'])
      d.set_loc_end(item['loc_end'])
      d.set_name(item['name'])
      for p in item['params']:
            d.add_parm(parse_argparm(FunParam(), 'parm', p))
      d.set_body(parse_block(item['body'], allow_index = True))
      return d

def parse_program(source):
      p = Program()
      for item in source:
            if type(item) == type({}):
                  t = item['type']
                  if t == 'decl': p.add_item(parse_fundecl(item))
                  elif t == 'fundef': p.add_item(parse_fundef(item))
                  else: unexpected(item)
            else: p.add_item(make_opaque(item))
      return p

#### Base visitor and dispatch ####

class BaseVisitor(object):
      def dispatch(self):
            if hasattr(self, 'dispatcher'):
                  return getattr(self, 'dispatcher')
            return self

#### Default visitor: just visit ####

class DefaultVisitor(BaseVisitor):
      def visit_program(self, program):
            return self.dispatch().visit_block(program)

      def visit_opaque(self, opaque):
            return opaque

      def visit_block(self, block):
            l = []
            for item in block.items:
                  if not hasattr(item, 'accept'):
                        print >>sys.stderr, "invalid item:"
                        pprint.pprint(item, stream=sys.stderr)
                        choke(block, "internal error")
                  new = item.accept(self)
                  if type(new) == type([]):
                        l += new
                  elif new is not None:
                        l.append(new)
            block.items = l
            return block

      def visit_fundecl(self, fundecl):
            p = []
            for parm in fundecl.parms:
                  new = parm.accept(self)
                  if type(new) == type([]):
                        p += new
                  elif new is not None:
                        p.append(new)
            fundecl.parms = p
            return fundecl

      def visit_fundef(self, fundef):
            self.dispatch().visit_fundecl(fundef)
            fundef.body.accept(self)
            return fundef

      def visit_getp(self, getp):
            return getp
      def visit_geta(self, geta):
            return geta

      def visit_setp(self, setp):
            setp.rhs.accept(self)
            return setp

      def visit_seta(self, seta):
            seta.rhs.accept(self)
            return seta

      def visit_create(self, create):
            if create.fid_lvalue is not None:
                  create.fid_lvalue.accept(self)
            create.place.accept(self)
            create.start.accept(self)
            create.step.accept(self)
            create.limit.accept(self)
            create.block.accept(self)
            if not create.funIsIdentifier():
                  create.fun.accept(self)
            a = []
            for arg in create.args:
                  new = arg.accept(self)
                  if type(new) == type([]):
                        a += new
                  elif new is not None:
                        a.append(new)
            create.args = a

            create.body.accept(self)
            if create.result_lvalue is not None:
                  create.result_lvalue.accept(self)

            return create

      def visit_funparm(self, parm):
            return parm

      def visit_createarg(self, arg):
            if arg.init is not None:
                  arg.init.accept(self)
            return arg

      def visit_end_thread(self, et):
            return et

      def visit_break(self, br):
            return br

#### Printer visitor: reprint SL code ####

class PrinterVisitor(DefaultVisitor):
      def __init__(self):
            self.buffer = ""

      def visit_opaque(self, opaque):
            if opaque.text is not None and opaque.text.startswith('#'):
                  self.buffer += '\n'
            self.buffer += opaque.text
            return opaque
            
      def visit_funparm(self, parm):
            self.buffer += ' sl_%s(%s, %s)' % (parm.type, parm.ctype, parm.name)
            return parm

      def visit_funheader(self, fun, htype):
            self.buffer += " sl_%s(%s, void" % (htype, fun.name)
            for parm in fun.parms:
                  self.buffer += ', '
                  parm.accept(self)
            self.buffer += ')'
            return fun

      def visit_fundecl(self, fundecl):
            return self.dispatch().visit_funheader(fundecl, 'decl')
      
      def visit_fundef(self, fundef):
            self.dispatch().visit_funheader(fundef, 'def')
            fundef.body.accept(self)
            self.buffer += ' sl_enddef '
            return fundef

      def visit_block(self, block):
            if block.indexname is not None:
                  self.buffer += '{ sl_index(%s); ' % block.indexname
            DefaultVisitor.visit_block(self, block)
            if block.indexname is not None:
                  self.buffer += '}'
            return block

      def visit_getp(self, vu):
            self.buffer += ' sl_getp(%s)' % vu.name
            return vu
      def visit_geta(self, vu):
            self.buffer += ' sl_geta(%s)' % vu.name
            return vu
      def visit_setp(self, vu):
            self.buffer += ' sl_setp(%s, ' % vu.name
            vu.rhs.accept(self)
            self.buffer += ')'
            return vu
      def visit_seta(self, vu):
            self.buffer += ' sl_seta(%s, ' % vu.name
            vu.rhs.accept(self)
            self.buffer += ')'
            return vu

      def visit_createarg(self, arg):
            self.buffer += ' sl_%s(%s, %s' % (arg.type, arg.ctype, arg.name)
            if arg.init is not None:
                  self.buffer += ','
                  arg.init.accept(self)
            self.buffer += ')'
            return arg

      def visit_break(self, br):
            self.buffer += ' sl_break '
            return br

      def visit_end_thread(self, et):
            self.buffer += ' sl_end_thread '
            return et

      def visit_create(self, c):
            self.buffer += ' sl_create('

            if c.fid_lvalue is not None:
                  c.fid_lvalue.accept(self)

            for b in (c.place, c.start, c.step, c.limit, c.block):
                  self.buffer += ','
                  b.accept(self)

            self.buffer += ',/**/,'

            if c.funIsIdentifier():
                  self.buffer += c.fun
            else:
                  c.fun.accept(self)

            for arg in c.args:
                  self.buffer += ','
                  arg.accept(self)
            self.buffer += ')'

            c.body.accept(self)
            
            if c.sync_type == 'release':
                  self.buffer += ' sl_release()'
            else:
                  self.buffer += ' sl_sync('
                  if c.result_lvalue is not None:
                        c.result_lvalue.accept(self)
                  self.buffer += ')'

            return c

#### Sequential transforms ####

def flatten(loc, opaquetext):
      if loc is not None:
            opaquetext = ('\n#line %d "%s"\n' % loc) + opaquetext
      o = Opaque()
      o.set_text(opaquetext)
      return o

class Create_2_Loop(DefaultVisitor):
      def __init__(self):
            self.decls = None
            self.callist = None
            self.protolist = None

      def visit_geta(self, geta):
            return flatten(geta.loc, "__slA_%s" % geta.name)
      
      def visit_seta(self, seta):
            b = seta.rhs.accept(self)
            return [flatten(seta.loc, "__slA_%s = " % seta.name), b]

      def visit_createarg(self, arg):
            # prepare declarations
            if arg.type.startswith('gl'):
                  reg = "register"
            else:
                  reg = ""
            if arg.init is None:
                  self.decls.append(flatten(arg.loc, "%s %s __slA_%s;" % (reg, arg.ctype, arg.name)))
            else:
                  init = arg.init.accept(self)
                  self.decls.append(flatten(arg.loc, "%s %s __slA_%s = " % (reg, arg.ctype, arg.name)))
                  self.decls.append(init)
                  self.decls.append(flatten(arg.loc, ";"))

            # prepare proto and uses
            if arg.type.startswith("sh"):
                  self.callist += ", &__slA_%s" % arg.name
                  self.protolist += ", %s *" % arg.ctype
            else:
                  self.callist += ", __slA_%s" % arg.name
                  self.protolist += ", %s" % arg.ctype

      def visit_create(self, cr):
            old_decls = self.decls  # allow for nested creates
            old_callist = self.callist 
            old_protolist = self.protolist
            self.decls = []
            self.callist = ""
            self.protolist = ""

            DefaultVisitor.visit_create(self, cr) # this will accumulate the arg declarations in self.decls

            newbl = []
            lbl = cr.label
            if cr.fid_lvalue is not None:
                  # we "consume" the FID lvalue, to force its evaluation
                  # in case it consumes side effects
                  newbl.append(flatten(cr.loc, "(void)("))
                  newbl.append(cr.fid_lvalue)
                  newbl.append(flatten(cr.loc, ");"))

            # ditto for the place expression, maybe it has side effects
            newbl.append(flatten(cr.loc, "(void)("))
            newbl.append(cr.place)
            newbl.append(flatten(cr.loc, "); register long __slC_ret_%s = 0; register const long __slC_st_%s = " 
                                 % (lbl, lbl)))
            newbl.append(cr.start)
            newbl.append(flatten(cr.loc, "; register const long __slC_li_%s = " % lbl))
            newbl.append(cr.limit)
            newbl.append(flatten(cr.loc, "; register const long __slC_stp_%s = " % lbl))
            newbl.append(cr.step)

            # again, we don't use the block value but maybe it has side effects
            newbl.append(flatten(cr.loc, "; (void)("))
            newbl.append(cr.block)
            
            # now generate the function pointer
            newbl.append(flatten(cr.loc, "); long (*__slC_fun_%s)(const long %s) = (long (*)(const long%s))(" %
                                 (lbl, self.protolist, self.protolist)))

            if cr.funIsIdentifier():
                  newbl.append(flatten(cr.loc, cr.fun))
            else:
                  newbl.append(cr.fun)
            newbl.append(flatten(cr.loc, ");"))

            newbl += self.decls # consume argument declarations / inits

            newbl.append(cr.body)    

            # here we expand the loop
            newbl.append(flatten(cr.loc_end, """
register long __slC_ix_%(lbl)s;
if (!__slC_stp_%(lbl)s)
   for (__slC_ix_%(lbl)s = __slC_st_%(lbl)s; ; __slC_ix_%(lbl)s += __slC_li_%(lbl)s)
     { if (SVP_ENORMAL != (__slC_ret_%(lbl)s = __slC_fun_%(lbl)s(__slC_ix_%(lbl)s%(callist)s))) break; }
else if (__slC_stp_%(lbl)s > 0)
   for (__slC_ix_%(lbl)s = __slC_st_%(lbl)s; __slC_ix_%(lbl)s < __slC_li_%(lbl)s; 
        __slC_ix_%(lbl)s += __slC_stp_%(lbl)s)
     { if (SVP_ENORMAL != (__slC_ret_%(lbl)s = __slC_fun_%(lbl)s(__slC_ix_%(lbl)s%(callist)s))) break; }
else
   for (__slC_ix_%(lbl)s = __slC_st_%(lbl)s; __slC_ix_%(lbl)s > __slC_li_%(lbl)s; 
        __slC_ix_%(lbl)s += __slC_stp_%(lbl)s)
     { if (SVP_ENORMAL != (__slC_ret_%(lbl)s = __slC_fun_%(lbl)s(__slC_ix_%(lbl)s%(callist)s))) break; }
""".replace('\n','') % {'lbl':lbl, 'callist':self.callist}))

            if cr.result_lvalue is not None:
                  newbl.append(flatten(cr.loc_end, "("))
                  newbl.append(cr.result_value)
                  newbl.append(flatten(cr.loc_end, ") = __slC_ret_%s" % lbl))

            self.decls = old_decls
            self.callist = old_callist
            self.protolist = old_protolist
            return newbl


class TFun_2_CFun(DefaultVisitor):

      def __init__(self):
            self.shlist = []
            self.gllist = []

      def visit_getp(self, getp):
            if getp.name in self.shlist:
                  format = "(*__slP_%s)"
            else:
                  format = "__slP_%s"
            return flatten(getp.loc, format % getp.name)

      def visit_setp(self, getp):
            b = getp.rhs.accept(self)
            if getp.name in self.shlist:
                  format = "(*__slP_%s) = "
            else:
                  format = "__slP_%s = "
            return [flatten(getp.loc, format % getp.name), b]

      def visit_funparm(self, parm):
            if parm.type.startswith("sh"):
                  self.shlist.append(parm.name)
                  self.buffer += ', register %s * const __restrict__ __slP_%s' % (parm.ctype, parm.name)
            else:
                  self.gllist.append(parm.name)
                  if parm.type.endswith('_mutable'):
                        const = ""
                  else:
                        const = "const"
                  self.buffer += ', register %s %s __slP_%s' % (parm.ctype, const, parm.name)
            return parm

      def visit_fundecl(self, fundecl):
            self.buffer = "long %s(const long __slI" % fundecl.name
            fundecl = DefaultVisitor.visit_fundecl(self, fundecl)
            self.buffer += ')'
            return flatten(fundecl.loc, self.buffer)

      def visit_fundef(self, fundef):
            self.shlist = []
            self.gllist = []

            newitems = []
            newitems.append(self.dispatch().visit_fundecl(fundef))
            newitems.append(flatten(fundef.loc, "{"))
            if fundef.body.indexname is not None:
                  newitems.append(flatten(fundef.loc, "register const long %s = __slI;" % fundef.body.indexname)) 
            b = fundef.body.accept(self)
            b.indexname = None 
            newitems.append(b)
            newitems.append(flatten(fundef.loc_end, "return SVP_ENORMAL; }"))
            return newitems

      def visit_break(self, br):
            return flatten(br.loc, "return SVP_EBROKEN")

      def visit_end_thread(self, et):
            return flatten(et.loc, "return SVP_ENORMAL")

#### MT-Alpha transforms ####

class MTA_RegisterMagic(object):

      # Magic numbers
      #iargregs = 6 # 1 reserved for PV
      #fargregs = 4
      iargregs = 12
      fargregs = 12
      ilocalregs = 19
      flocalregs = 19

      legacy_fregs = {
         # Scratch registers
         'ft0' : 10,
         'ft1' : 11,
         'ft2' : 12,
         'ft3' : 13,
         'ft4' : 14,
         'ft5' : 15,
         'ft6' : 22,
         'ft7' : 23,
         'ft8' : 24,
         'ft9' : 25,
         'ft10' : 26,
         'ft11' : 27,
         'ft12' : 28,
         'ft13' : 29,
         'ft14' : 30,
         # Return value registers
         'frv' : 0,
         'frv2' : 1,
         # Incoming parameters
         'fa0' : 16,
         'fa1' : 17,
         'fa2' : 18,
         'fa3' : 19,
         'fa4' : 20,
         'fa5' : 21,
         # Call-save registers
         'fs0' : 2,
         'fs1' : 3,
         'fs2' : 4,
         'fs3' : 5,
         'fs4' : 6,
         'fs5' : 7,
         'fs6' : 8,
         'fs7' : 9,
         # Zero 
         'fzero' : 31,
         }
   
      legacy_regs = {
         # function temporaries
         't0' : 1,
         't1' : 2,
         't2' : 3,
         't3' : 4,
         't4' : 5,
         't5' : 6,
         't6' : 7,
         't7' : 8,
         't8' : 22,
         't9' : 23,
         't10' : 24,
         't11' : 25,
         # assembly scratch
         'at' : 28,
         # return value
         'rv' : 0,
         # incoming parameters
         'a5' : 21,
         'a4' : 20,
         'a3' : 19,
         'a2' : 18,
         'a1' : 17,
         'a0' : 16,
         # procedure function / temporary
         'pv' : 27,
         't12' : 27,
         # Callee-save registers
         's0' : 9,
         's1' : 10,
         's2' : 11,
         's3' : 12,
         's4' : 13,
         's5' : 14,
         # Return address
         'ra' : 26,
         # Frame pointer / callee save
         'fp' : 15,
         's6' : 15,
         # Global pointer
         'gp' : 29,
         # Stack pointer
         'sp' : 30,
         # Zero
         'zero' : 31
         }
   
   
       ######################
       # GCC Allocation order
       ######################
       # #define REG_ALLOC_ORDER {
       #    1, 2, 3, 4, 5, 6, 7, 8,      /* nonsaved integer registers */
       #    22, 23, 24, 25, 28,          /* likewise */
       #    0,                           /* likewise, but return value */
       #    21, 20, 19, 18, 17, 16,      /* likewise, but input args */
       #    27,                          /* likewise, but OSF procedure value */
       #    f10, f11, f12, f13, f14, f15,      /* nonsaved floating-point registers */
       #    f22, f23, f24, f25, f26, f27,      /* likewise */
       #    f28, f29, f30,                  /* likewise */
       #    f0, f1,                      /* likewise, but return values */
       #    f21, f20, f19, f18, f17, f16,      /* likewise, but input args */
       #    9, 10, 11, 12, 13, 14,       /* saved integer registers */
       #    26,                          /* return address */
       #    15,                          /* hard frame pointer */
       #    f2, f3, f4, f5, f6, f7,      /* saved floating-point registers */
       #    f8, f9,                      /* likewise */
       #    29, 30, 31, f31               /* gp, sp, ap, sfp */
       # }
   
   
      reg_mapping = {
         # Globals
         'g0' : 't11',
         'g1' : 't10',
         'g2' : 't9',
         'g3' : 't8',
         'g4' : 't7',
         'g5' : 't6',
         'g6' : 't5',
         'g7' : 't4',
         'g8' : 't3',
         'g9' : 't2',
         'g10' : 't1',
         'g11' : 't0',
   
         'gf0' : 'ft11',
         'gf1' : 'ft10',
         'gf2' : 'ft9',
         'gf3' : 'ft8',
         'gf4'  : 'ft7',
         'gf5' : 'ft6',
         'gf6' : 'ft5',
         'gf7' : 'ft4',
         'gf8' : 'ft3',
         'gf9' : 'ft2',
         'gf10' : 'ft1',
         'gf11' : 'ft0',
         
         # Shareds
         's0' : 't0',
         'd0' : 't1',
         's1' : 't2',
         'd1' : 't3',
         's2' : 't4',
         'd2' : 't5',
         's3' : 't6',
         'd3' : 't7',
         's4' : 't8',
         'd4' : 't9',
         's5' : 't10',
         'd5' : 't11',
   
         'sf0' : 'ft0',
         'df0' : 'ft1',
         'sf1' : 'ft2',
         'df1' : 'ft3',
         'sf2' : 'ft4',
         'df2' : 'ft5',
         'sf3' : 'ft6',
         'df3' : 'ft7',
         'sf4' : 'ft8',
         'df4' : 'ft9',
         'sf5' : 'ft10',
         'df5' : 'ft11',
         
         'lf31' : 'fzero',
         
         'lf0' : 'ft12',
         'lf1' : 'ft13',
         'lf2' : 'ft14',
         'lf3' : 'frv',
         'lf4' : 'frv2',
         'lf5' : 'fa5',
         'lf6' : 'fa4',
         'lf7' : 'fa3',
         'lf8' : 'fa2',
         'lf9' : 'fa1',
         'lf10' : 'fa0',
         'lf11' : 'fs0',
         'lf12' : 'fs1',
         'lf13' : 'fs2',
         'lf14' : 'fs3',
         'lf15' : 'fs4',
         'lf16' : 'fs5',
         'lf17' : 'fs6',
         'lf18' : 'fs7',
   
         # Special locals
         'l31' : 'zero',
         'l18' : 'sp',
         'l17' : 'gp',
         'l16' : 'fp',
         'l15' : 'ra',
         'l14' : 'pv',
         'l13' : 's5',
   
         'l12' : 's4',
         'l11' : 's3',
         'l10' : 's2',
         'l9' : 's1',
         'l8' : 's0',
         'l7' : 'a0',
         'l6' : 'a1',
         'l5' : 'a2',
         'l4' : 'a3',
         'l3' : 'a4',
         'l2' : 'a5',
         'l1' : 'rv',
         'l0' : 'at',
         }
   
      reg_aliases = {
         'tlsp' : 'l18',
         'gp' : 'l17',
         'pv' : 'l14',
         'ra' : 'l15',
         'fp' : 'l16',
         'rv' : 'l1',
         'idx_init' : 'l0',
         'basearg' : 'l1',
         'zero' : 'l31',
         'frv' : 'lf3',
         'fzero' : 'lf31',
         'fbasearg' : 'lf1'
         }
   
      def __init__(self):
            regs = { 
               'i' : { 'l' : [None]*32, 'g' : [None]*32, 's' : [None]*32, 'd' : [None]*32 },
               'f' : { 'l' : [None]*32, 'g' : [None]*32, 's' : [None]*32, 'd' : [None]*32 },
               }
            reg_inv = map(lambda x:[], xrange(32))
            freg_inv = map(lambda x:[], xrange(32))
            aliases = {}

            for r,t in self.reg_mapping.items():
               cat = r[0]
               if r[1] == 'f':
                  species = 'f'
                  nr = int(r[2:])
                  legnr = self.legacy_fregs[t]
                  inv_dic = freg_inv
               else:
                  species = 'i'
                  nr = int(r[1:])
                  legnr = self.legacy_regs[t]
                  inv_dic = reg_inv

               reg = { 'species' : species, 'cat' : cat, 'name' : r, 'legname' : t, 'nr' : nr, 'legnr' : legnr }
               if aliases.has_key(r):
                  die("alias %s already defined" % r)
               aliases[r] = reg
               if regs[species][cat][nr] is not None:
                  die("register %s already defined" % r)
               regs[species][cat][nr] = reg
               inv_dic[legnr].append(reg)

            for a,k in self.reg_aliases.items():
               if aliases.has_key(a):
                  die("alias %s already defined" % a)
               aliases[a] = aliases[k]

            # Consistency check
            for i in reg_inv:
               if len(i) == 0:
                  die("all legacy integer registers are not used")
            if i in freg_inv:
               if len(i) == 0:
                  die("all legacy fp registers are not used")

            self.reg_inv = reg_inv
            self.freg_inv = freg_inv
            self.regs = regs
            self.aliases = aliases

      
      def mapcall(self, loc, funcname, args):
            dic = { 
               'i' : { 'sh' : [], 'gl' : [] },
               'f' : { 'sh' : [], 'gl' : [] },
               }
            anames = {}
            #print args
            for a in args:
               cat = a.type[:2]
               if a.type[2] == 'f':
                     species = 'f'                     
               else:
                     species = 'i'
               if a.type.endswith('_mutable'):
                     mode = 'w'
               else:
                     mode = 'r'

               na = {'loc':a.loc, 'cat':cat, 'species':species, 'ctype':a.ctype, 'name':a.name, 'init':getattr(a, 'init', None), 'glmode':mode}
               anames[a.name] = na
               dic[species][cat].append(na)

            # Check if some parameters will use memory passing
            escape = 0      
            if len(dic['f']['sh']) * 2 + len(dic['f']['gl']) > self.fargregs:
               escape = 1
            if len(dic['i']['sh']) * 2 + len(dic['i']['gl']) > (self.iargregs - escape):
               escape = 1

            # Start allocate

            islots_avail = self.iargregs - escape
            fslots_avail = self.fargregs

            # Allocate shareds first
            if len(dic['i']['sh']) * 2 > islots_avail:
               choke(loc, "%s: too many int shareds, cannot pass them via memory yet" % funcname)
            shc = 0
            for s in dic['i']['sh']:
               s['mode'] = 'reg'
               s['regnr'] = shc
               shc += 1
               islots_avail -= 2
            nrishareds = shc

            if len(dic['f']['sh']) > fslots_avail:
               choke(loc, "%s: too many float shareds, cannot pass them via memory yet" % funcname)
            shc = 0
            for s in dic['f']['sh']:
               s['mode'] = 'reg'
               s['regnr'] = shc
               shc += 1
               fslots_avail -= 2
            nrfshareds = shc

            # Allocate fp globals
            glc = 0
            memlayout = []
            offset = 0
            for s in dic['f']['gl']:
               if fslots_avail > 0:
                  s['mode'] = 'reg'
                  s['regnr'] = glc
                  glc += 1
                  fslots_avail -= 1
               else:
                  s['mode'] = 'mem'
                  s['offset'] = offset
                  offset += 1
                  memlayout.append(s)
            nrfglobals = glc

            glc = 0
            for s in dic['i']['gl']:
               if islots_avail > 0:
                  s['mode'] = 'reg'
                  s['regnr'] = glc
                  glc += 1
                  islots_avail -= 1
               else:
                  s['mode'] = 'mem'
                  s['offset'] = offset
                  offset += 1
                  memlayout.append(s)
            nriglobals = glc

            ret = {}
            if escape == 0:
               ret['gl_mem_offset'] = None
            else:
               warn(loc, "%s: some arguments are passed via memory" % funcname)
               nriglobals = glc + 1
               ret['gl_mem_offset'] = glc

            # nriglobals = nriglobals + 1 # count PV

            ret['nrargregs'] = { 'gli' : nriglobals, 'shi' : nrishareds,
                                 'glf' : nrfglobals, 'shf' : nrfshareds }
            ret['args'] = dic
            ret['nargs'] = anames
            ret['memlayout'] = memlayout

            #pprint.pprint(ret)

            return ret

      def vreg_to_legacy(self, vreg):
            if vreg['species'] == 'f':
                  return "$f%d" % vreg['legnr']
            else:
                  return "$%d" % vreg['legnr']

      def get_vreg(self, vname):
            return self.aliases[vname]

      def vname_to_legacy(self, vname):
            return self.vreg_to_legacy(self.get_vreg(vname))


class Create_2_MTACreate(DefaultVisitor):
      def __init__(self, magic = None):
            self.args = {}
            self.lbl = None
            if magic is not None:
                  self.magic = magic
            else:
                  self.magic = MTA_RegisterMagic()

      def visit_geta(self, geta):
            return flatten(geta.loc, "__slA_%s" % geta.name)

      def visit_seta(self, seta):
            b = seta.rhs.accept(self)
            
            name = seta.name
            assert self.args.has_key(name)

            a = self.args[name]
            lbl = self.lbl

            newbl = []
            if a['mode'] == 'mem':
                  newbl.append(flatten(seta.loc, "__slC_ma_%s.%s = __slA_%s = " % (lbl, name, name)))
                  newbl.append(b)
            else:
                  ctype = a['ctype']
                  if a['cat'] == 'sh': 
                        insn = 'puts'
                        assign = ""
                  else: 
                        assign = "__slA_%s = " % name
                        insn = 'putg'
                  if a['species'] == 'f': 
                        insn = 'f' + insn
                        rspec = 'f'
                  else: rspec = 'rI'
                  regnr = a['regnr']
                  newbl.append(flatten(seta.loc, """
__asm__ ("%(insn)s %%2, %%0, %(regnr)d\t# set arg %(name)s"
 : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
   "%(rspec)s"(%(assign)s(%(ctype)s)(
""".replace('\n','') % locals()))
                  newbl.append(b)
                  newbl.append(flatten(seta.loc, ")))"))
            return newbl
                  

      def visit_create(self, cr):

            newbl = []
            lbl = cr.label

            newbl.append(flatten(cr.loc, "register const long __slC_pl_%s = " % lbl))
            newbl.append(cr.place.accept(self))
            newbl.append(flatten(cr.loc, "; register const long __slC_st_%s = " % lbl)) 
            newbl.append(cr.start.accept(self))
            newbl.append(flatten(cr.loc, "; register const long __slC_li_%s = " % lbl))
            newbl.append(cr.limit.accept(self))
            newbl.append(flatten(cr.loc, "; register const long __slC_stp_%s = " % lbl))
            newbl.append(cr.step.accept(self))
            newbl.append(flatten(cr.loc, "; register const long __slC_bl_%s = " % lbl))
            newbl.append(cr.block.accept(self))
            newbl.append(flatten(cr.loc, "; register void (*__slC_fun_%s)(void) = (void (*)(void))(" % lbl))
            if cr.funIsIdentifier():
                  newbl.append(flatten(cr.loc, cr.fun))
            else:
                  newbl.append(cr.fun.accept(self))
            newbl.append(flatten(cr.loc, ");"))


            c = self.magic.mapcall(cr.loc, "create", cr.args)

            if c['gl_mem_offset'] is not None:
                  newbl.append(flatten(cr.loc, "struct {"))
                  for d in c['memlayout']:
                        newbl.append(flatten(d['loc'], "%s %s;" % (d['ctype'], d['name'])))
                  newbl.append(flatten(cr.loc, "} __slC_ma_%s;" % lbl))

            inis = []
            for name, arg in c['nargs'].iteritems():
                  ctype = arg['ctype']
                  loc = arg['loc']
                  newbl.append(flatten(loc, "%s __slA_%s;" % (ctype, name)))
                  if arg['init'] is not None:
                        newbl.append(flatten(loc, "%s const __slAi_%s = " % (ctype, name)))
                        newbl.append(arg['init'].accept(self))
                        newbl.append(flatten(loc, ";"))
                        ini = SetArg()
                        ini.set_loc(loc)
                        ini.set_name(name)
                        ini.set_rhs(make_opaque('__slAi_%s' % name))
                        b = Block()
                        b.add_item(ini)
                        inis.append(b)
                        inis.append(flatten(loc, ';'))
            newbl.append(flatten(cr.loc, """
register long __slC_fid_%(lbl)s;
__asm__ __volatile__("allocate %%1, %%0\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "rI"(__slC_pl_%(lbl)s));
__asm__ ("setstart %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_st_%(lbl)s));
__asm__ ("setlimit %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_li_%(lbl)s));
__asm__ ("setstep %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_stp_%(lbl)s));
__asm__ ("setblock %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_bl_%(lbl)s));
__asm__ __volatile__("wmb; crei %%0, 0(%%2)\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
    "r"(__slC_fun_%(lbl)s) : "memory");
""".replace('\n','') % { 'lbl': lbl }))

            old_args = self.args 
            old_lbl = self.lbl
            self.args = c['nargs']
            self.lbl = lbl

            for ini in inis:
                  newbl.append(ini.accept(self))

            newbl.append(cr.body.accept(self))

            self.args = old_args
            self.lbl = old_lbl

            # here handle sync
            
            if c['gl_mem_offset'] is not None:
                  newbl.append(flatten(cr.loc_end, """
__asm__ ("wmb; putg %%2, %%0, %(offset)d\t#MT: set offset for memargs"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
    "r"(&__slC_ma_%(lbl)s));
""".replace('\n','') % { 'lbl':lbl, 'offset':c['gl_mem_offset']} ))

            if cr.sync_type == 'normal':
                  newbl.append(flatten(cr.loc_end, """
register long __slC_ret_%(lbl)s;
__asm__ __volatile__("sync %%0, %%1; mov %%1, $31\t# MT: SYNC %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s), "=r"(__slC_ret_%(lbl)s)
  : "0"(__slC_fid_%(lbl)s) : "memory");
""".replace('\n','') % { 'lbl':lbl }))

                  for name, arg in c['nargs'].iteritems():
                        if arg['mode'] == 'reg' and arg['cat'] == 'sh':
                              if arg['species'] == 'f':
                                    insn1 = 'fgets'
                                    insn2 = 'fmov'
                                    rspec = 'f'
                              else:
                                    insn1 = 'gets'
                                    insn2 = 'mov'
                                    rspec = 'r'
                              regnr = arg['regnr']
                              newbl.append(flatten(cr.loc_end, """
__asm__ ("%(insn1)s %%0, %(regnr)d, %%1; %(insn2)s %%1, %%1\t# MT: get shared %(name)s"
  : "=r"(__slC_fid_%(lbl)s), "=%(rspec)s"(__slA_%(name)s)
  : "0"(__slC_fid_%(lbl)s));
""".replace('\n','') % locals()))
    
                              

                  newbl.append(flatten(cr.loc_end, """
__asm__ __volatile__("release %%0\t#MT: SYNC %(lbl)s"
  : : "r"(__slC_fid_%(lbl)s));
""".replace('\n','') % { 'lbl':lbl }))

                  if cr.result_lvalue is not None:
                        newbl.append(flatten(cr.loc_end, "("))
                        newbl.append(cr.result_lvalue.accept(self))
                        newbl.append(flatten(cr.loc_end, ") = __slC_ret_%s" % lbl))

            return newbl



class TFun_2_MTATFun(DefaultVisitor):
      def __init__(self, magic = None):
            if magic is not None:
                  self.magic = magic
            else:
                  self.magic = MTA_RegisterMagic()
                  

      def visit_fundecl(self, fundecl):
            return flatten(fundecl.loc, "void %s(void)" % fundecl.name)
      
      def visit_fundef(self, fundef):
            newitems = []
            
            c = self.magic.mapcall(fundef.loc, "function '%s'" % fundef.name, fundef.parms)

            self.gllist = []
            self.shlist = []
            self.gllist_mem = []
            self.gllist_mutable = []
                          

            newitems.append(flatten(fundef.loc,
"""
extern void %(name)s(void);
void __slf_%(name)s(void) {
   register long __slI __asm__("%(indexreg)s");
   __asm__("# MT: index in %%0 (must be %(indexreg)s)" : "=r"(__slI));
   __asm__ __volatile__(".registers %(gli)d %(shi)d %(li)d %(glf)d %(shf)d %(lf)d\n");
""".replace('\n','') % { 'name': fundef.name, 
                         'gli' : c['nrargregs']['gli'],
                         'shi' : c['nrargregs']['shi'],
                         'glf' : c['nrargregs']['glf'],
                         'shf' : c['nrargregs']['shf'],
                         'li' : self.magic.ilocalregs,
                         'lf' : self.magic.flocalregs,
                         'indexreg' : self.magic.vname_to_legacy("idx_init") }))

            if c['gl_mem_offset'] is not None:
                  newitems.append(flatten(fundef.loc, "register const struct {"))
                  for d in c['memlayout']:
                        self.gllist_mem.append(d['name'])
                        newitems.append(flatten(d['loc'], "%s %s;" % (d['ctype'], d['name'])))
                  newitems.append(flatten(fundef.loc, '} * __restrict__ const __slPgm __asm__("%s");' % 
                                          self.magic.vname_to_legacy('g%d' % c['gl_mem_offset'])))

                  
            for species,d1 in c['args'].items():
               for cat,d2 in d1.items():
                  for a in d2:
                     name = a['name']
                     ctype = a['ctype']
                     if a['mode'] == 'mem':
                        assert cat == 'gl'
                        self.gllist_mem.append(name)
                     else: # mode: reg
                        regnr = a['regnr']
                        if cat == "sh":
                              self.shlist.append(name)                              
                              if species == "f":                                   
                                    dreg = "df%d" % regnr
                                    sreg = "sf%d" % regnr
                              else:
                                    dreg = "d%d" % regnr
                                    sreg = "s%d" % regnr
                              newitems.append(flatten(a['loc'], """
register %(ctype)s __slPsin_%(name)s __asm__("%(dreg)s");
register %(ctype)s __slPsout_%(name)s __asm__("%(sreg)s");
""".replace('\n','') % { 'name':name, 'ctype':ctype, 
                         'dreg': self.magic.vname_to_legacy(dreg),
                         'sreg':self.magic.vname_to_legacy(sreg) }))

                        else: # cat: gl
                              self.gllist.append(name)                              
                              if species == "f":
                                    reg = "gf%d" % regnr
                              else:
                                    reg = "g%d" % regnr
                              newitems.append(flatten(a['loc'], 'register %s const __slPg_%s __asm__("%s");' % (ctype, name, self.magic.vname_to_legacy(reg))))

            for p in fundef.parms:
                  if p.type.endswith('_mutable'):
                        self.gllist_mutable.append(p.name)
                        if p.name in self.gllist_mem:
                              orig = "__slPgm->%s" % p.name
                        else:
                              orig = "__slPg_%s" % p.aname
                        newitems.append(flatten(p.loc, "%s __slPwg_%s = %s;" % (p.ctype, p.name, orig)))

            if fundef.body.indexname is not None:
                  newitems.append(flatten(fundef.loc, "register const long %s = __slI;" % fundef.body.indexname)) 

            b = fundef.body.accept(self)
            b.indexname = None
            newitems.append(b)
            newitems.append(flatten(fundef.loc_end, "__sl_end: (void)0; }"))
            return newitems

      def visit_getp(self, getp):
            if getp.name in self.gllist_mutable:
                  return flatten(getp.loc, '__slPwg_%s' % getp.name)
            elif getp.name in self.shlist:
                  return flatten(getp.loc, """
({
__asm__ __volatile__("# MT: read shared %(name)s (%%0)"
  : "=rf"(__slPsin_%(name)s)
  : "0"(__slPsin_%(name)s));
__slPsin_%(name)s;
})
""".replace('\n','') % { 'name': getp.name })
            elif getp.name in self.gllist_mem:
                  return flatten(getp.loc, "(__slPgm->%s)" % getp.name)
            else: # normal global
                  assert getp.name in self.gllist
                  return flatten(getp.loc, "__slPg_%s" % getp.name)

      def visit_setp(self, setp):
            rhs = setp.rhs.accept(self)
            if setp.name in self.shlist:
                  p = { 'name' : setp.name }
                  b = []
                  b.append(flatten(setp.loc, """
do {
__asm__ __volatile__("# MT: clobber incoming %(name)s (%%0)"
  : "=rf"(__slPsin_%(name)s) : "0"(__slPsin_%(name)s));
__typeof__(__slPsout_%(name)s) __tmp_set_%(name)s = (
""".replace('\n','') % p))
                  b.append(rhs)
                  b.append(flatten(setp.loc, """); 
__asm__ __volatile__("# MT: start write shared %(name)s (%%0)"
  : "=rf"(__slPsout_%(name)s) : "0"(__slPsout_%(name)s));
__asm__ __volatile__("mov %%4, %%0\t# MT: write shared %(name)s (%%0)"
  : "=rf" (__slPsout_%(name)s), "=rf" (__slPsin_%(name)s)
  : "0"(__slPsout_%(name)s), "1" (__slPsin_%(name)s), 
    "rf" (__tmp_set_%(name)s));
} while(0)
""".replace('\n','') % p))
                  return b
            else:
                  assert setp.name in self.gllist_mem or setp.name in self.gllist
                  return flatten(setp.loc, "#error invalid set to global %s\n" % setp.name)               

      def visit_break(self, br):
            return flatten(br.loc, """do { __asm__ __volatile__("break; end\tMT: break"); __builtin_unreachable(); } while(0)""")

      def visit_end_thread(self, et):
            return flatten(et.loc, "goto __sl_end")
            

if __name__ == "__main__":
      source = eval('["""'+sys.stdin.read()+'"""]')

      source = cleanup(source)

      print "##### SOURCE #####"
      pprint.pprint(source)

      print "#### PARSE ####"
      p = parse_program(source)

      print "#### CHECK ####"
      p.accept(DefaultVisitor())

      print "#### PRINT ORIG ####"
      pp = PrinterVisitor()
      p.accept(pp)
      print pp.buffer

      print "#### TFUN -> MTA_TFUN ####"
      pmt = p.accept(TFun_2_MTATFun())
      
      print "#### PRINT MTA_TFUN ####"
      pp = PrinterVisitor()
      pmt.accept(pp)
      print pp.buffer

      print "#### CREATE -> MTA_CREATE ####"
      pmtc = p.accept(Create_2_MTACreate())
      
      print "#### PRINT MTA_CREATE ####"
      pp = PrinterVisitor()
      pmtc.accept(pp)
      print pp.buffer

      
      # print "#### TFUN -> CFUN ####"
      # ps = p.accept(TFun_2_CFun())

      # print "#### PRINT CFUN ####"
      # pp = PrinterVisitor()
      # ps.accept(pp)
      # print pp.buffer

      # print "#### CREATE -> LOOP ####"
      # pc = p.accept(Create_2_Loop())

      # print "#### PRINT LOOP ####"
      # pp = PrinterVisitor()
      # ps.accept(pp)
      # print pp.buffer
