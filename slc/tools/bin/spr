#! /usr/bin/env python
#
# spr: This file is part of the SL toolchain.
#
import sys
import re
import pprint

from slc.mtalpha import regmagic
from slc.msg import die, log
from slc.ast import *
from slc.visitors import *
from slc.lower.seq import *
from slc.lower.lowercreate import *

#### Abstract syntax tree ####


#### Parser ####


def cleanup(source):
      # remove extra whitespace
      if type(source) == type([]):
            return [x for x in (cleanup(y) for y in source) if len(x) != 0]
      elif type(source) == type(""):
            #if re_endswithline.match(source) is not None:
            #      return source.lstrip()
            return source.strip(' \t')
      elif type(source) == type({}):
            return dict( ( (k,cleanup(v)) for (k,v) in source.iteritems() ) )
      else: 
            die("unknown item type: %r" % source)


def unexpected(item):
      die("unexpected construct '%s'" % item.get('type','unknown'), item)


def parse_varuse(varuse, item):
      #print "parse varuse %x: item %x: %r" % (id(varuse), id(item), item)
      varuse.loc = item['loc']
      varuse.name = item['name']
      if item.has_key('body'):
            varuse.rhs = parse_block(item['body'], False)
      return varuse

def parse_create(item):
      c = Create(loc = item['loc'],
                 loc_end = item['loc_end'],
                 label = item['lbl'],
                 place = parse_block(item['place'], False),
                 start = parse_block(item['start'], False),
                 limit = parse_block(item['limit'], False),
                 step = parse_block(item['step'], False),
                 block = parse_block(item['block'], False),
                 sync_type = item['sync'],
                 fun = parse_block(item['fun'], False),
                 body = parse_block(item['body'], False))
                 
      for p in item['args']:
            c.args.append(parse_argparm(CreateArg(), 'arg', p))

      if 'result' in item and item['result']:
            c.result_lvalue = parse_block(item['result'], False)

      return c

def parse_block(items, allow_index = False):
      if len(items) == 0:
            return None
      b = Block()
      #print "new block %x (len %d)" % (id(b), len(b))
      for item in items:
            #print "parse block %x (len %d): item %x: %r" % (id(b), len(b), id(item), item)
            if isinstance(item, dict):
                  t = item['type']
                  if t == 'indexdecl' and allow_index: b.indexname = item['name']
                  elif t == 'getp': b += parse_varuse(GetP(), item)
                  elif t == 'setp': b += parse_varuse(SetP(), item)
                  elif t == 'geta': b += parse_varuse(GetA(), item)
                  elif t == 'seta': b += parse_varuse(SetA(), item)
                  elif t == 'create': b += parse_create(item)
                  elif t == 'break': b += parse_break(item)
                  elif t == 'end_thread': b += parse_end_thread(item)
                  else: unexpected(item)
            else: 
                  assert isinstance(item, str)
                  b += Opaque(item)
            #print "parse block %x: item %x -- END (len %d)" % (id(b), id(item), len(b))
      return b

def parse_argparm(p, cat, item):
      #print "parse argparm %x: item %x: %r" % (id(p), id(item), item)
      if not item['type'].endswith(cat):
            unexpected(item)
      p.loc = item['loc']
      p.type = item['type']
      p.ctype = item['ctype']
      p.name = item['name']
      if item.has_key('init'):
         p.init = parse_block(item['init'], False)
      return p            

def parse_break(item):
      return Break(loc = item['loc'])

def parse_end_thread(item):
      return EndThread(loc = item['loc'])

def parse_fundecl(item):
      d = FunDecl(loc = item['loc'], name = item['name'])
      for p in item['params']:
            d += parse_argparm(FunParm(), 'parm', p)
      return d

def parse_fundef(item):
      d = FunDef(loc = item['loc'], 
                 loc_end = item['loc_end'], 
                 name = item['name'],
                 body = parse_block(item['body'], allow_index = True))
      for p in item['params']:
            d += parse_argparm(FunParm(), 'parm', p)
      return d

def parse_program(source):
      p = Program()
      for item in source:
            if type(item) == type({}):
                  t = item['type']
                  if t == 'decl': p += parse_fundecl(item)
                  elif t == 'fundef': p += parse_fundef(item)
                  else: unexpected(item)
            else: p += Opaque(item)
      return p

#### MT-Alpha transforms ####


class Create_2_MTACreate(DefaultVisitor):
      def __init__(self):
            self.args = {}
            self.lbl = None

      def visit_geta(self, geta):
            return flatten(geta.loc, "__slA_%s" % geta.name)

      def visit_seta(self, seta):
            b = seta.rhs.accept(self)
            
            name = seta.name
            assert self.args.has_key(name)

            a = self.args[name]
            lbl = self.lbl

            newbl = []
            if a['mode'] == 'mem':
                  newbl.append(flatten(seta.loc, "__slC_ma_%s.%s = __slA_%s = " % (lbl, name, name)))
                  newbl.append(b)
            else:
                  ctype = a['ctype']
                  if a['cat'] == 'sh': 
                        insn = 'puts'
                        assign = ""
                  else: 
                        assign = "__slA_%s = " % name
                        insn = 'putg'
                  if a['species'] == 'f': 
                        insn = 'f' + insn
                        rspec = 'f'
                  else: rspec = 'rI'
                  regnr = a['regnr']
                  newbl.append(flatten(seta.loc, """
__asm__ ("%(insn)s %%2, %%0, %(regnr)d\t# set arg %(name)s"
 : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
   "%(rspec)s"(%(assign)s(%(ctype)s)(
""".replace('\n','') % locals()))
                  newbl.append(b)
                  newbl.append(flatten(seta.loc, ")))"))
            return newbl
                  

      def visit_create(self, cr):

            newbl = Block(loc = cr.loc)
            lbl = cr.label

            newbl += flatten(cr.loc, "register const long __slC_pl_%s = " % lbl)
            newbl += cr.place.accept(self)
            newbl += flatten(cr.loc, "; register const long __slC_st_%s = " % lbl)
            newbl += cr.start.accept(self)
            newbl += flatten(cr.loc, "; register const long __slC_li_%s = " % lbl)
            newbl += cr.limit.accept(self)
            newbl += flatten(cr.loc, "; register const long __slC_stp_%s = " % lbl)
            newbl += cr.step.accept(self)
            newbl += flatten(cr.loc, "; register const long __slC_bl_%s = " % lbl)
            newbl += cr.block.accept(self)
            newbl += flatten(cr.loc, "; register void (*__slC_fun_%s)(void) = (void (*)(void))(" % lbl)
            if cr.funIsIdentifier():
                  newbl += flatten(cr.loc, cr.fun)
            else:
                  newbl += cr.fun.accept(self)
            newbl += flatten(cr.loc, ");")


            c = regmagic.mapcall(cr.args, funcname = "create", loc = cr.loc)

            if c['gl_mem_offset'] is not None:
                  newbl += flatten(cr.loc, "struct {")
                  for d in c['memlayout']:
                        newbl += flatten(d['loc'], "%s %s;" % (d['ctype'], d['name']))
                  newbl += flatten(cr.loc, "} __slC_ma_%s;" % lbl)

            inis = []
            for name, arg in c['nargs'].iteritems():
                  ctype = arg['ctype']
                  loc = arg['loc']
                  newbl += flatten(loc, "%s __slA_%s;" % (ctype, name))
                  if arg['init'] is not None:
                        newbl += flatten(loc, "%s const __slAi_%s = " % (ctype, name))
                        newbl += arg['init'].accept(self)
                        newbl += flatten(loc, ";")
                        inis.append(SetA(loc = loc, 
                                         name = name, 
                                         rhs = Opaque('__slAi_%s' % name)))
                        inis.append(flatten(loc, ';'))
            newbl += flatten(cr.loc, """
register long __slC_fid_%(lbl)s;
__asm__ __volatile__("allocate %%1, %%0\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "rI"(__slC_pl_%(lbl)s));
__asm__ ("setstart %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_st_%(lbl)s));
__asm__ ("setlimit %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_li_%(lbl)s));
__asm__ ("setstep %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_stp_%(lbl)s));
__asm__ ("setblock %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_bl_%(lbl)s));
__asm__ __volatile__("wmb; crei %%0, 0(%%2)\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
    "r"(__slC_fun_%(lbl)s) : "memory");
""".replace('\n','') % { 'lbl': lbl })

            old_args = self.args 
            old_lbl = self.lbl
            self.args = c['nargs']
            self.lbl = lbl

            for ini in inis:
                  newbl += ini.accept(self)

            newbl += cr.body.accept(self)

            self.args = old_args
            self.lbl = old_lbl

            # here handle sync
            
            if c['gl_mem_offset'] is not None:
                  newbl += flatten(cr.loc_end, """
__asm__ ("wmb; putg %%2, %%0, %(offset)d\t#MT: set offset for memargs"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
    "r"(&__slC_ma_%(lbl)s));
""".replace('\n','') % { 'lbl':lbl, 'offset':c['gl_mem_offset']} )

            if cr.sync_type == 'normal':
                  newbl += flatten(cr.loc_end, """
register long __slC_ret_%(lbl)s;
__asm__ __volatile__("sync %%0, %%1; mov %%1, $31\t# MT: SYNC %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s), "=r"(__slC_ret_%(lbl)s)
  : "0"(__slC_fid_%(lbl)s) : "memory");
""".replace('\n','') % { 'lbl':lbl })

                  for name, arg in c['nargs'].iteritems():
                        if arg['mode'] == 'reg' and arg['cat'] == 'sh':
                              if arg['species'] == 'f':
                                    insn1 = 'fgets'
                                    insn2 = 'fmov'
                                    rspec = 'f'
                              else:
                                    insn1 = 'gets'
                                    insn2 = 'mov'
                                    rspec = 'r'
                              regnr = arg['regnr']
                              newbl += flatten(cr.loc_end, """
__asm__ ("%(insn1)s %%0, %(regnr)d, %%1; %(insn2)s %%1, %%1\t# MT: get shared %(name)s"
  : "=r"(__slC_fid_%(lbl)s), "=%(rspec)s"(__slA_%(name)s)
  : "0"(__slC_fid_%(lbl)s));
""".replace('\n','') % locals())
    
                              

                  newbl += flatten(cr.loc_end, """
__asm__ __volatile__("release %%0\t#MT: SYNC %(lbl)s"
  : : "r"(__slC_fid_%(lbl)s));
""".replace('\n','') % { 'lbl':lbl })

                  if cr.result_lvalue is not None:
                        newbl += flatten(cr.loc_end, "(")
                        newbl += cr.result_lvalue.accept(self)
                        newbl += flatten(cr.loc_end, ") = __slC_ret_%s" % lbl)

            return newbl



class TFun_2_MTATFun(DefaultVisitor):
      def __init__(self):
            pass

      def visit_fundecl(self, fundecl):
            return flatten(fundecl.loc, "void %s(void)" % fundecl.name)
      
      def visit_fundef(self, fundef):
            newitems = []
            
            c = regmagic.mapcall(fundef.parms, 
                                 funcname = "function '%s'" % fundef.name, 
                                 loc = fundef.loc)

            self.gllist = []
            self.shlist = []
            self.gllist_mem = []
            self.gllist_mutable = []
                          

            newitems.append(flatten(fundef.loc,
"""
extern void %(name)s(void);
void __slf_%(name)s(void) {
   register long __slI __asm__("%(indexreg)s");
   __asm__("# MT: index in %%0 (must be %(indexreg)s)" : "=r"(__slI));
   __asm__ __volatile__("%(regdir)s\n");
""".replace('\n','') % { 'name': fundef.name, 
                         'regdir' : regmagic.get_dot_registers(c['nrargregs']['gli'],
                                                               c['nrargregs']['shi'],
                                                               c['nrargregs']['glf'],
                                                               c['nrargregs']['shf']),
                         'indexreg' : regmagic.vname_to_legacy("idx_init") }))

            if c['gl_mem_offset'] is not None:
                  newitems.append(flatten(fundef.loc, "register const struct {"))
                  for d in c['memlayout']:
                        self.gllist_mem.append(d['name'])
                        newitems.append(flatten(d['loc'], "%s %s;" % (d['ctype'], d['name'])))
                  newitems.append(flatten(fundef.loc, '} * __restrict__ const __slPgm __asm__("%s");' % 
                                          regmagic.vname_to_legacy('g%d' % c['gl_mem_offset'])))

                  
            for species,d1 in c['args'].items():
               for cat,d2 in d1.items():
                  for a in d2:
                     name = a['name']
                     ctype = a['ctype']
                     if a['mode'] == 'mem':
                        assert cat == 'gl'
                        self.gllist_mem.append(name)
                     else: # mode: reg
                        regnr = a['regnr']
                        if cat == "sh":
                              self.shlist.append(name)                              
                              if species == "f":                                   
                                    dreg = "df%d" % regnr
                                    sreg = "sf%d" % regnr
                              else:
                                    dreg = "d%d" % regnr
                                    sreg = "s%d" % regnr
                              newitems.append(flatten(a['loc'], """
register %(ctype)s __slPsin_%(name)s __asm__("%(dreg)s");
register %(ctype)s __slPsout_%(name)s __asm__("%(sreg)s");
""".replace('\n','') % { 'name':name, 'ctype':ctype, 
                         'dreg': regmagic.vname_to_legacy(dreg),
                         'sreg': regmagic.vname_to_legacy(sreg) }))

                        else: # cat: gl
                              self.gllist.append(name)                              
                              if species == "f":
                                    reg = "gf%d" % regnr
                              else:
                                    reg = "g%d" % regnr
                              newitems.append(flatten(a['loc'], 'register %s const __slPg_%s __asm__("%s");' % (ctype, name, regmagic.vname_to_legacy(reg))))

            for p in fundef.parms:
                  if p.type.endswith('_mutable'):
                        self.gllist_mutable.append(p.name)
                        if p.name in self.gllist_mem:
                              orig = "__slPgm->%s" % p.name
                        else:
                              orig = "__slPg_%s" % p.aname
                        newitems.append(flatten(p.loc, "%s __slPwg_%s = %s;" % (p.ctype, p.name, orig)))

            if fundef.body.indexname is not None:
                  newitems.append(flatten(fundef.loc, "register const long %s = __slI;" % fundef.body.indexname)) 

            b = fundef.body.accept(self)
            b.indexname = None
            newitems.append(b)
            newitems.append(flatten(fundef.loc_end, "__sl_end: (void)0; }"))
            return newitems

      def visit_getp(self, getp):
            if getp.name in self.gllist_mutable:
                  return flatten(getp.loc, '__slPwg_%s' % getp.name)
            elif getp.name in self.shlist:
                  return flatten(getp.loc, """
({
__asm__ __volatile__("# MT: read shared %(name)s (%%0)"
  : "=rf"(__slPsin_%(name)s)
  : "0"(__slPsin_%(name)s));
__slPsin_%(name)s;
})
""".replace('\n','') % { 'name': getp.name })
            elif getp.name in self.gllist_mem:
                  return flatten(getp.loc, "(__slPgm->%s)" % getp.name)
            else: # normal global
                  assert getp.name in self.gllist
                  return flatten(getp.loc, "__slPg_%s" % getp.name)

      def visit_setp(self, setp):
            rhs = setp.rhs.accept(self)
            if setp.name in self.shlist:
                  p = { 'name' : setp.name }
                  b = []
                  b.append(flatten(setp.loc, """
do {
__asm__ __volatile__("# MT: clobber incoming %(name)s (%%0)"
  : "=rf"(__slPsin_%(name)s) : "0"(__slPsin_%(name)s));
__typeof__(__slPsout_%(name)s) __tmp_set_%(name)s = (
""".replace('\n','') % p))
                  b.append(rhs)
                  b.append(flatten(setp.loc, """); 
__asm__ __volatile__("# MT: start write shared %(name)s (%%0)"
  : "=rf"(__slPsout_%(name)s) : "0"(__slPsout_%(name)s));
__asm__ __volatile__("mov %%4, %%0\t# MT: write shared %(name)s (%%0)"
  : "=rf" (__slPsout_%(name)s), "=rf" (__slPsin_%(name)s)
  : "0"(__slPsout_%(name)s), "1" (__slPsin_%(name)s), 
    "rf" (__tmp_set_%(name)s));
} while(0)
""".replace('\n','') % p))
                  return b
            else:
                  assert setp.name in self.gllist_mem or setp.name in self.gllist
                  return flatten(setp.loc, "#error invalid set to global %s\n" % setp.name)               

      def visit_break(self, br):
            return flatten(br.loc, """do { __asm__ __volatile__("break; end\tMT: break"); __builtin_unreachable(); } while(0)""")

      def visit_endthread(self, et):
            return flatten(et.loc, "goto __sl_end")
            

if __name__ == "__main__":
      source = eval('["""'+sys.stdin.read()+'"""]')

      source = cleanup(source)

      print "##### SOURCE #####"
      pprint.pprint(source)

      print "#### PARSE ####"
      p = parse_program(source)

      print "#### CHECK ####"
      p.accept(DefaultVisitor())

      print "#### PRINT ORIG ####"
      pp = PrinterVisitor()
      p.accept(pp)

      print "#### CREATE -> LOWCREATE ####"
      plc = p.accept(Create_2_LowCreate())

      print "#### PRINT LOWCREATE ####"
      plc.accept(pp)

      # print "#### TFUN -> MTA_TFUN ####"
      # pmt = plc.accept(TFun_2_MTATFun())
      
      # print "#### PRINT MTA_TFUN ####"
      # pmt.accept(pp)

      # print "#### CREATE -> MTA_CREATE ####"
      # pmtc = pmt.accept(Create_2_MTACreate())
      
      # print "#### PRINT MTA_CREATE ####"
      # pmtc.accept(pp)
      
      print "#### TFUN -> CFUN ####"
      ps = plc.accept(TFun_2_CFun())

      print "#### PRINT CFUN ####"
      ps.accept(pp)

      print "#### CREATE -> LOOP ####"
      pc = ps.accept(Create_2_Loop())

      print "#### PRINT LOOP ####"
      pc.accept(pp)
