#! /usr/bin/env python
#
# spr: This file is part of the SL toolchain.
#
import sys
import re
import pprint

from slc.mtalpha import regmagic
from slc.msg import die, log
from slc.ast import *


#### Abstract syntax tree ####


#### Parser ####


def cleanup(source):
      # remove extra whitespace
      if type(source) == type([]):
            return [x for x in (cleanup(y) for y in source) if len(x) != 0]
      elif type(source) == type(""):
            #if re_endswithline.match(source) is not None:
            #      return source.lstrip()
            return source.strip(' \t')
      elif type(source) == type({}):
            return dict( ( (k,cleanup(v)) for (k,v) in source.iteritems() ) )
      else: 
            die("unknown item type: %r" % source)


def unexpected(item):
      die("unexpected construct '%s'" % item.get('type','unknown'), item)


def isemptyblock(item):
      return item == [] or (len(item) == 1 and len(item[0]) == 0)

def parse_varuse(varuse, item):
      #print "parse varuse %x: item %x: %r" % (id(varuse), id(item), item)
      varuse.loc = item['loc']
      varuse.name = item['name']
      if item.has_key('body'):
            varuse.rhs = parse_block(item['body'], False)
      return varuse

def parse_create(item):
      c = Create(loc = item['loc'],
                 loc_end = item['loc_end'],
                 label = item['lbl'],
                 place = parse_block(item['place'], False),
                 start = parse_block(item['start'], False),
                 limit = parse_block(item['limit'], False),
                 step = parse_block(item['step'], False),
                 block = parse_block(item['block'], False),
                 sync_type = item['sync'],
                 fun = parse_block(item['fun'], False),
                 body = parse_block(item['body'], False))
                 
      for p in item['args']:
            c.args.append(parse_argparm(CreateArg(), 'arg', p))


      if 'result' in item and item['result']:
            c.result_lvalue = parse_block(item['result'], False)

      if 'fid' in item and item['fid']:
            c.fid_lvalue = parse_block(item['fid'], False)

      return c

def parse_block(items, allow_index = False):
      if len(items) == 0:
            return None
      b = Block()
      #print "new block %x (len %d)" % (id(b), len(b))
      for item in items:
            #print "parse block %x (len %d): item %x: %r" % (id(b), len(b), id(item), item)
            if isinstance(item, dict):
                  t = item['type']
                  if t == 'indexdecl' and allow_index: b.indexname = item['name']
                  elif t == 'getp': b += parse_varuse(GetP(), item)
                  elif t == 'setp': b += parse_varuse(SetP(), item)
                  elif t == 'geta': b += parse_varuse(GetA(), item)
                  elif t == 'seta': b += parse_varuse(SetA(), item)
                  elif t == 'create': b += parse_create(item)
                  elif t == 'break': b += parse_break(item)
                  elif t == 'end_thread': b += parse_end_thread(item)
                  else: unexpected(item)
            else: 
                  assert isinstance(item, str)
                  b += Opaque(item)
            #print "parse block %x: item %x -- END (len %d)" % (id(b), id(item), len(b))
      return b

def parse_argparm(p, cat, item):
      #print "parse argparm %x: item %x: %r" % (id(p), id(item), item)
      if not item['type'].endswith(cat):
            unexpected(item)
      p.loc = item['loc']
      p.type = item['type']
      p.ctype = item['ctype']
      p.name = item['name']
      if item.has_key('init'):
         p.init = parse_block(item['init'], False)
      return p            

def parse_break(item):
      return Break(loc = item['loc'])

def parse_end_thread(item):
      return EndThread(loc = item['loc'])

def parse_fundecl(item):
      d = FunDecl(loc = item['loc'], name = item['name'])
      for p in item['params']:
            d += parse_argparm(FunParm(), 'parm', p)
      return d

def parse_fundef(item):
      d = FunDef(loc = item['loc'], 
                 loc_end = item['loc_end'], 
                 name = item['name'],
                 body = parse_block(item['body'], allow_index = True))
      for p in item['params']:
            d += parse_argparm(FunParm(), 'parm', p)
      return d

def parse_program(source):
      p = Program()
      for item in source:
            if type(item) == type({}):
                  t = item['type']
                  if t == 'decl': p += parse_fundecl(item)
                  elif t == 'fundef': p += parse_fundef(item)
                  else: unexpected(item)
            else: p += Opaque(item)
      return p

#### Base visitor and dispatch ####

class BaseVisitor(object):
      def dispatch(self):
            if hasattr(self, 'dispatcher'):
                  return getattr(self, 'dispatcher')
            return self

#### Default visitor: just visit ####

class DefaultVisitor(BaseVisitor):
      def visit_program(self, program):
            return self.dispatch().visit_block(program)

      def visit_opaque(self, opaque):
            return opaque

      def visit_block(self, block):
            newbl = Block()
            # print "visiting block %x: %r" % (id(block), block)
            for item in block:
                  # print "in block %x: item %x: %r" % (id(block), id(item), item)
                  newbl += item.accept(self)
            block.reset(newbl)
            #print "return %x: %r" % (id(block), block)
            return block

      def visit_fundecl(self, fundecl):
            p = FunDecl()
            for parm in fundecl.parms:
                  p += parm.accept(self)
            fundecl.reset(p)
            return fundecl

      def visit_fundef(self, fundef):
            self.dispatch().visit_fundecl(fundef)
            fundef.body.accept(self)
            return fundef

      def visit_getp(self, getp):
            return getp
      def visit_geta(self, geta):
            return geta

      def visit_setp(self, setp):
            setp.rhs.accept(self)
            return setp

      def visit_seta(self, seta):
            seta.rhs.accept(self)
            return seta

      def visit_create(self, create):
            if create.fid_lvalue is not None:
                  create.fid_lvalue.accept(self)
            create.place.accept(self)
            create.start.accept(self)
            create.step.accept(self)
            create.limit.accept(self)
            create.block.accept(self)
            if not create.funIsIdentifier():
                  create.fun.accept(self)
            a = []
            for arg in create.args:
                  new = arg.accept(self)
                  if type(new) == type([]):
                        a += new
                  elif new is not None:
                        a.append(new)
            create.args = a

            create.body.accept(self)
            if create.result_lvalue is not None:
                  create.result_lvalue.accept(self)

            return create

      def visit_funparm(self, parm):
            return parm

      def visit_createarg(self, arg):
            if arg.init is not None:
                  arg.init.accept(self)
            return arg

      def visit_endthread(self, et):
            return et

      def visit_break(self, br):
            return br

#### Printer visitor: reprint SL code ####

class PrinterVisitor(DefaultVisitor):
      def __init__(self):
            self.buffer = ""

      def visit_opaque(self, opaque):
            if opaque.text is not None and opaque.text.startswith('#'):
                  self.buffer += '\n'
            self.buffer += opaque.text
            return opaque
            
      def visit_funparm(self, parm):
            self.buffer += ' sl_%s(%s, %s)' % (parm.type, parm.ctype, parm.name)
            return parm

      def visit_funheader(self, fun, htype):
            self.buffer += " sl_%s(%s, void" % (htype, fun.name)
            for parm in fun.parms:
                  self.buffer += ', '
                  parm.accept(self)
            self.buffer += ')'
            return fun

      def visit_fundecl(self, fundecl):
            return self.dispatch().visit_funheader(fundecl, 'decl')
      
      def visit_fundef(self, fundef):
            self.dispatch().visit_funheader(fundef, 'def')
            fundef.body.accept(self)
            self.buffer += ' sl_enddef '
            return fundef

      def visit_block(self, block):
            if block.indexname is not None:
                  self.buffer += '{ sl_index(%s); ' % block.indexname
            #print "visiting %x: block %x: %r" % (id(self), id(block), block)
            DefaultVisitor.visit_block(self, block)
            if block.indexname is not None:
                  self.buffer += '}'
            return block

      def visit_getp(self, vu):
            self.buffer += ' sl_getp(%s)' % vu.name
            return vu
      def visit_geta(self, vu):
            self.buffer += ' sl_geta(%s)' % vu.name
            return vu
      def visit_setp(self, vu):
            self.buffer += ' sl_setp(%s, ' % vu.name
            vu.rhs.accept(self)
            self.buffer += ')'
            return vu
      def visit_seta(self, vu):
            self.buffer += ' sl_seta(%s, ' % vu.name
            vu.rhs.accept(self)
            self.buffer += ')'
            return vu

      def visit_createarg(self, arg):
            self.buffer += ' sl_%s(%s, %s' % (arg.type, arg.ctype, arg.name)
            if arg.init is not None:
                  self.buffer += ','
                  arg.init.accept(self)
            self.buffer += ')'
            return arg

      def visit_break(self, br):
            self.buffer += ' sl_break '
            return br

      def visit_endthread(self, et):
            self.buffer += ' sl_end_thread '
            return et

      def visit_create(self, c):
            self.buffer += ' sl_create('

            if c.fid_lvalue is not None:
                  c.fid_lvalue.accept(self)

            for b in (c.place, c.start, c.step, c.limit, c.block):
                  self.buffer += ','
                  b.accept(self)

            self.buffer += ',/**/,'

            if c.funIsIdentifier():
                  self.buffer += c.fun
            else:
                  c.fun.accept(self)

            for arg in c.args:
                  self.buffer += ','
                  arg.accept(self)
            self.buffer += ')'

            c.body.accept(self)
            
            if c.sync_type == 'release':
                  self.buffer += ' sl_release()'
            else:
                  self.buffer += ' sl_sync('
                  if c.result_lvalue is not None:
                        c.result_lvalue.accept(self)
                  self.buffer += ')'

            return c

#### Sequential transforms ####

def flatten(loc, opaquetext):
      if loc is not None:
            opaquetext = ('\n%s\n' % loc.ppline()) + opaquetext
      return Opaque(opaquetext)

class Create_2_Loop(DefaultVisitor):
      def __init__(self):
            self.decls = None
            self.callist = None
            self.protolist = None

      def visit_geta(self, geta):
            return flatten(geta.loc, "__slA_%s" % geta.name)
      
      def visit_seta(self, seta):
            b = seta.rhs.accept(self)
            return [flatten(seta.loc, "__slA_%s = " % seta.name), b]

      def visit_createarg(self, arg):
            # prepare declarations
            if arg.type.startswith('gl'):
                  reg = "register"
            else:
                  reg = ""
            if arg.init is None:
                  self.decls.append(flatten(arg.loc, "%s %s __slA_%s;" % (reg, arg.ctype, arg.name)))
            else:
                  init = arg.init.accept(self)
                  self.decls.append(flatten(arg.loc, "%s %s __slA_%s = " % (reg, arg.ctype, arg.name)))
                  self.decls.append(init)
                  self.decls.append(flatten(arg.loc, ";"))

            # prepare proto and uses
            if arg.type.startswith("sh"):
                  self.callist += ", &__slA_%s" % arg.name
                  self.protolist += ", %s *" % arg.ctype
            else:
                  self.callist += ", __slA_%s" % arg.name
                  self.protolist += ", %s" % arg.ctype

      def visit_create(self, cr):
            old_decls = self.decls  # allow for nested creates
            old_callist = self.callist 
            old_protolist = self.protolist
            self.decls = []
            self.callist = ""
            self.protolist = ""

            DefaultVisitor.visit_create(self, cr) # this will accumulate the arg declarations in self.decls

            newbl = []
            lbl = cr.label
            if cr.fid_lvalue is not None:
                  # we "consume" the FID lvalue, to force its evaluation
                  # in case it consumes side effects
                  newbl.append(flatten(cr.loc, "(void)("))
                  newbl.append(cr.fid_lvalue)
                  newbl.append(flatten(cr.loc, ");"))

            # ditto for the place expression, maybe it has side effects
            newbl.append(flatten(cr.loc, "(void)("))
            newbl.append(cr.place)
            newbl.append(flatten(cr.loc, "); register long __slC_ret_%s = 0; register const long __slC_st_%s = " 
                                 % (lbl, lbl)))
            newbl.append(cr.start)
            newbl.append(flatten(cr.loc, "; register const long __slC_li_%s = " % lbl))
            newbl.append(cr.limit)
            newbl.append(flatten(cr.loc, "; register const long __slC_stp_%s = " % lbl))
            newbl.append(cr.step)

            # again, we don't use the block value but maybe it has side effects
            newbl.append(flatten(cr.loc, "; (void)("))
            newbl.append(cr.block)
            
            # now generate the function pointer
            newbl.append(flatten(cr.loc, "); long (*__slC_fun_%s)(const long %s) = (long (*)(const long%s))(" %
                                 (lbl, self.protolist, self.protolist)))

            if cr.funIsIdentifier():
                  newbl.append(flatten(cr.loc, cr.fun))
            else:
                  newbl.append(cr.fun)
            newbl.append(flatten(cr.loc, ");"))

            newbl += self.decls # consume argument declarations / inits

            newbl.append(cr.body)    

            # here we expand the loop
            newbl.append(flatten(cr.loc_end, """
register long __slC_ix_%(lbl)s;
if (!__slC_stp_%(lbl)s)
   for (__slC_ix_%(lbl)s = __slC_st_%(lbl)s; ; __slC_ix_%(lbl)s += __slC_li_%(lbl)s)
     { if (SVP_ENORMAL != (__slC_ret_%(lbl)s = __slC_fun_%(lbl)s(__slC_ix_%(lbl)s%(callist)s))) break; }
else if (__slC_stp_%(lbl)s > 0)
   for (__slC_ix_%(lbl)s = __slC_st_%(lbl)s; __slC_ix_%(lbl)s < __slC_li_%(lbl)s; 
        __slC_ix_%(lbl)s += __slC_stp_%(lbl)s)
     { if (SVP_ENORMAL != (__slC_ret_%(lbl)s = __slC_fun_%(lbl)s(__slC_ix_%(lbl)s%(callist)s))) break; }
else
   for (__slC_ix_%(lbl)s = __slC_st_%(lbl)s; __slC_ix_%(lbl)s > __slC_li_%(lbl)s; 
        __slC_ix_%(lbl)s += __slC_stp_%(lbl)s)
     { if (SVP_ENORMAL != (__slC_ret_%(lbl)s = __slC_fun_%(lbl)s(__slC_ix_%(lbl)s%(callist)s))) break; }
""".replace('\n','') % {'lbl':lbl, 'callist':self.callist}))

            if cr.result_lvalue is not None:
                  newbl.append(flatten(cr.loc_end, "("))
                  newbl.append(cr.result_value)
                  newbl.append(flatten(cr.loc_end, ") = __slC_ret_%s" % lbl))

            self.decls = old_decls
            self.callist = old_callist
            self.protolist = old_protolist
            return newbl


class TFun_2_CFun(DefaultVisitor):

      def __init__(self):
            self.shlist = []
            self.gllist = []

      def visit_getp(self, getp):
            if getp.name in self.shlist:
                  format = "(*__slP_%s)"
            else:
                  format = "__slP_%s"
            return flatten(getp.loc, format % getp.name)

      def visit_setp(self, getp):
            b = getp.rhs.accept(self)
            if getp.name in self.shlist:
                  format = "(*__slP_%s) = "
            else:
                  format = "__slP_%s = "
            return [flatten(getp.loc, format % getp.name), b]

      def visit_funparm(self, parm):
            if parm.type.startswith("sh"):
                  self.shlist.append(parm.name)
                  self.buffer += ', register %s * const __restrict__ __slP_%s' % (parm.ctype, parm.name)
            else:
                  self.gllist.append(parm.name)
                  if parm.type.endswith('_mutable'):
                        const = ""
                  else:
                        const = "const"
                  self.buffer += ', register %s %s __slP_%s' % (parm.ctype, const, parm.name)
            return parm

      def visit_fundecl(self, fundecl):
            self.buffer = "long %s(const long __slI" % fundecl.name
            fundecl = DefaultVisitor.visit_fundecl(self, fundecl)
            self.buffer += ')'
            return flatten(fundecl.loc, self.buffer)

      def visit_fundef(self, fundef):
            self.shlist = []
            self.gllist = []

            newitems = []
            newitems.append(self.dispatch().visit_fundecl(fundef))
            newitems.append(flatten(fundef.loc, "{"))
            if fundef.body.indexname is not None:
                  newitems.append(flatten(fundef.loc, "register const long %s = __slI;" % fundef.body.indexname)) 
            b = fundef.body.accept(self)
            b.indexname = None 
            newitems.append(b)
            newitems.append(flatten(fundef.loc_end, "return SVP_ENORMAL; }"))
            return newitems

      def visit_break(self, br):
            return flatten(br.loc, "return SVP_EBROKEN")

      def visit_endthread(self, et):
            return flatten(et.loc, "return SVP_ENORMAL")

#### MT-Alpha transforms ####


class Create_2_MTACreate(DefaultVisitor):
      def __init__(self):
            self.args = {}
            self.lbl = None

      def visit_geta(self, geta):
            return flatten(geta.loc, "__slA_%s" % geta.name)

      def visit_seta(self, seta):
            b = seta.rhs.accept(self)
            
            name = seta.name
            assert self.args.has_key(name)

            a = self.args[name]
            lbl = self.lbl

            newbl = []
            if a['mode'] == 'mem':
                  newbl.append(flatten(seta.loc, "__slC_ma_%s.%s = __slA_%s = " % (lbl, name, name)))
                  newbl.append(b)
            else:
                  ctype = a['ctype']
                  if a['cat'] == 'sh': 
                        insn = 'puts'
                        assign = ""
                  else: 
                        assign = "__slA_%s = " % name
                        insn = 'putg'
                  if a['species'] == 'f': 
                        insn = 'f' + insn
                        rspec = 'f'
                  else: rspec = 'rI'
                  regnr = a['regnr']
                  newbl.append(flatten(seta.loc, """
__asm__ ("%(insn)s %%2, %%0, %(regnr)d\t# set arg %(name)s"
 : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
   "%(rspec)s"(%(assign)s(%(ctype)s)(
""".replace('\n','') % locals()))
                  newbl.append(b)
                  newbl.append(flatten(seta.loc, ")))"))
            return newbl
                  

      def visit_create(self, cr):

            newbl = Block(loc = cr.loc)
            lbl = cr.label

            newbl += flatten(cr.loc, "register const long __slC_pl_%s = " % lbl)
            newbl += cr.place.accept(self)
            newbl += flatten(cr.loc, "; register const long __slC_st_%s = " % lbl)
            newbl += cr.start.accept(self)
            newbl += flatten(cr.loc, "; register const long __slC_li_%s = " % lbl)
            newbl += cr.limit.accept(self)
            newbl += flatten(cr.loc, "; register const long __slC_stp_%s = " % lbl)
            newbl += cr.step.accept(self)
            newbl += flatten(cr.loc, "; register const long __slC_bl_%s = " % lbl)
            newbl += cr.block.accept(self)
            newbl += flatten(cr.loc, "; register void (*__slC_fun_%s)(void) = (void (*)(void))(" % lbl)
            if cr.funIsIdentifier():
                  newbl += flatten(cr.loc, cr.fun)
            else:
                  newbl += cr.fun.accept(self)
            newbl += flatten(cr.loc, ");")


            c = regmagic.mapcall(cr.args, funcname = "create", loc = cr.loc)

            if c['gl_mem_offset'] is not None:
                  newbl += flatten(cr.loc, "struct {")
                  for d in c['memlayout']:
                        newbl += flatten(d['loc'], "%s %s;" % (d['ctype'], d['name']))
                  newbl += flatten(cr.loc, "} __slC_ma_%s;" % lbl)

            inis = []
            for name, arg in c['nargs'].iteritems():
                  ctype = arg['ctype']
                  loc = arg['loc']
                  newbl += flatten(loc, "%s __slA_%s;" % (ctype, name))
                  if arg['init'] is not None:
                        newbl += flatten(loc, "%s const __slAi_%s = " % (ctype, name))
                        newbl += arg['init'].accept(self)
                        newbl += flatten(loc, ";")
                        inis.append(SetA(loc = loc, 
                                         name = name, 
                                         rhs = Opaque('__slAi_%s' % name)))
                        inis.append(flatten(loc, ';'))
            newbl += flatten(cr.loc, """
register long __slC_fid_%(lbl)s;
__asm__ __volatile__("allocate %%1, %%0\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "rI"(__slC_pl_%(lbl)s));
__asm__ ("setstart %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_st_%(lbl)s));
__asm__ ("setlimit %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_li_%(lbl)s));
__asm__ ("setstep %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_stp_%(lbl)s));
__asm__ ("setblock %%0, %%2\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s), "rI"(__slC_bl_%(lbl)s));
__asm__ __volatile__("wmb; crei %%0, 0(%%2)\t# MT: CREATE %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
    "r"(__slC_fun_%(lbl)s) : "memory");
""".replace('\n','') % { 'lbl': lbl })

            old_args = self.args 
            old_lbl = self.lbl
            self.args = c['nargs']
            self.lbl = lbl

            for ini in inis:
                  newbl += ini.accept(self)

            newbl += cr.body.accept(self)

            self.args = old_args
            self.lbl = old_lbl

            # here handle sync
            
            if c['gl_mem_offset'] is not None:
                  newbl += flatten(cr.loc_end, """
__asm__ ("wmb; putg %%2, %%0, %(offset)d\t#MT: set offset for memargs"
  : "=r"(__slC_fid_%(lbl)s) : "0"(__slC_fid_%(lbl)s),
    "r"(&__slC_ma_%(lbl)s));
""".replace('\n','') % { 'lbl':lbl, 'offset':c['gl_mem_offset']} )

            if cr.sync_type == 'normal':
                  newbl += flatten(cr.loc_end, """
register long __slC_ret_%(lbl)s;
__asm__ __volatile__("sync %%0, %%1; mov %%1, $31\t# MT: SYNC %(lbl)s"
  : "=r"(__slC_fid_%(lbl)s), "=r"(__slC_ret_%(lbl)s)
  : "0"(__slC_fid_%(lbl)s) : "memory");
""".replace('\n','') % { 'lbl':lbl })

                  for name, arg in c['nargs'].iteritems():
                        if arg['mode'] == 'reg' and arg['cat'] == 'sh':
                              if arg['species'] == 'f':
                                    insn1 = 'fgets'
                                    insn2 = 'fmov'
                                    rspec = 'f'
                              else:
                                    insn1 = 'gets'
                                    insn2 = 'mov'
                                    rspec = 'r'
                              regnr = arg['regnr']
                              newbl += flatten(cr.loc_end, """
__asm__ ("%(insn1)s %%0, %(regnr)d, %%1; %(insn2)s %%1, %%1\t# MT: get shared %(name)s"
  : "=r"(__slC_fid_%(lbl)s), "=%(rspec)s"(__slA_%(name)s)
  : "0"(__slC_fid_%(lbl)s));
""".replace('\n','') % locals())
    
                              

                  newbl += flatten(cr.loc_end, """
__asm__ __volatile__("release %%0\t#MT: SYNC %(lbl)s"
  : : "r"(__slC_fid_%(lbl)s));
""".replace('\n','') % { 'lbl':lbl })

                  if cr.result_lvalue is not None:
                        newbl += flatten(cr.loc_end, "(")
                        newbl += cr.result_lvalue.accept(self)
                        newbl += flatten(cr.loc_end, ") = __slC_ret_%s" % lbl)

            return newbl



class TFun_2_MTATFun(DefaultVisitor):
      def __init__(self):
            pass

      def visit_fundecl(self, fundecl):
            return flatten(fundecl.loc, "void %s(void)" % fundecl.name)
      
      def visit_fundef(self, fundef):
            newitems = []
            
            c = regmagic.mapcall(fundef.parms, 
                                 funcname = "function '%s'" % fundef.name, 
                                 loc = fundef.loc)

            self.gllist = []
            self.shlist = []
            self.gllist_mem = []
            self.gllist_mutable = []
                          

            newitems.append(flatten(fundef.loc,
"""
extern void %(name)s(void);
void __slf_%(name)s(void) {
   register long __slI __asm__("%(indexreg)s");
   __asm__("# MT: index in %%0 (must be %(indexreg)s)" : "=r"(__slI));
   __asm__ __volatile__("%(regdir)s\n");
""".replace('\n','') % { 'name': fundef.name, 
                         'regdir' : regmagic.get_dot_registers(c['nrargregs']['gli'],
                                                               c['nrargregs']['shi'],
                                                               c['nrargregs']['glf'],
                                                               c['nrargregs']['shf']),
                         'indexreg' : regmagic.vname_to_legacy("idx_init") }))

            if c['gl_mem_offset'] is not None:
                  newitems.append(flatten(fundef.loc, "register const struct {"))
                  for d in c['memlayout']:
                        self.gllist_mem.append(d['name'])
                        newitems.append(flatten(d['loc'], "%s %s;" % (d['ctype'], d['name'])))
                  newitems.append(flatten(fundef.loc, '} * __restrict__ const __slPgm __asm__("%s");' % 
                                          regmagic.vname_to_legacy('g%d' % c['gl_mem_offset'])))

                  
            for species,d1 in c['args'].items():
               for cat,d2 in d1.items():
                  for a in d2:
                     name = a['name']
                     ctype = a['ctype']
                     if a['mode'] == 'mem':
                        assert cat == 'gl'
                        self.gllist_mem.append(name)
                     else: # mode: reg
                        regnr = a['regnr']
                        if cat == "sh":
                              self.shlist.append(name)                              
                              if species == "f":                                   
                                    dreg = "df%d" % regnr
                                    sreg = "sf%d" % regnr
                              else:
                                    dreg = "d%d" % regnr
                                    sreg = "s%d" % regnr
                              newitems.append(flatten(a['loc'], """
register %(ctype)s __slPsin_%(name)s __asm__("%(dreg)s");
register %(ctype)s __slPsout_%(name)s __asm__("%(sreg)s");
""".replace('\n','') % { 'name':name, 'ctype':ctype, 
                         'dreg': regmagic.vname_to_legacy(dreg),
                         'sreg': regmagic.vname_to_legacy(sreg) }))

                        else: # cat: gl
                              self.gllist.append(name)                              
                              if species == "f":
                                    reg = "gf%d" % regnr
                              else:
                                    reg = "g%d" % regnr
                              newitems.append(flatten(a['loc'], 'register %s const __slPg_%s __asm__("%s");' % (ctype, name, regmagic.vname_to_legacy(reg))))

            for p in fundef.parms:
                  if p.type.endswith('_mutable'):
                        self.gllist_mutable.append(p.name)
                        if p.name in self.gllist_mem:
                              orig = "__slPgm->%s" % p.name
                        else:
                              orig = "__slPg_%s" % p.aname
                        newitems.append(flatten(p.loc, "%s __slPwg_%s = %s;" % (p.ctype, p.name, orig)))

            if fundef.body.indexname is not None:
                  newitems.append(flatten(fundef.loc, "register const long %s = __slI;" % fundef.body.indexname)) 

            b = fundef.body.accept(self)
            b.indexname = None
            newitems.append(b)
            newitems.append(flatten(fundef.loc_end, "__sl_end: (void)0; }"))
            return newitems

      def visit_getp(self, getp):
            if getp.name in self.gllist_mutable:
                  return flatten(getp.loc, '__slPwg_%s' % getp.name)
            elif getp.name in self.shlist:
                  return flatten(getp.loc, """
({
__asm__ __volatile__("# MT: read shared %(name)s (%%0)"
  : "=rf"(__slPsin_%(name)s)
  : "0"(__slPsin_%(name)s));
__slPsin_%(name)s;
})
""".replace('\n','') % { 'name': getp.name })
            elif getp.name in self.gllist_mem:
                  return flatten(getp.loc, "(__slPgm->%s)" % getp.name)
            else: # normal global
                  assert getp.name in self.gllist
                  return flatten(getp.loc, "__slPg_%s" % getp.name)

      def visit_setp(self, setp):
            rhs = setp.rhs.accept(self)
            if setp.name in self.shlist:
                  p = { 'name' : setp.name }
                  b = []
                  b.append(flatten(setp.loc, """
do {
__asm__ __volatile__("# MT: clobber incoming %(name)s (%%0)"
  : "=rf"(__slPsin_%(name)s) : "0"(__slPsin_%(name)s));
__typeof__(__slPsout_%(name)s) __tmp_set_%(name)s = (
""".replace('\n','') % p))
                  b.append(rhs)
                  b.append(flatten(setp.loc, """); 
__asm__ __volatile__("# MT: start write shared %(name)s (%%0)"
  : "=rf"(__slPsout_%(name)s) : "0"(__slPsout_%(name)s));
__asm__ __volatile__("mov %%4, %%0\t# MT: write shared %(name)s (%%0)"
  : "=rf" (__slPsout_%(name)s), "=rf" (__slPsin_%(name)s)
  : "0"(__slPsout_%(name)s), "1" (__slPsin_%(name)s), 
    "rf" (__tmp_set_%(name)s));
} while(0)
""".replace('\n','') % p))
                  return b
            else:
                  assert setp.name in self.gllist_mem or setp.name in self.gllist
                  return flatten(setp.loc, "#error invalid set to global %s\n" % setp.name)               

      def visit_break(self, br):
            return flatten(br.loc, """do { __asm__ __volatile__("break; end\tMT: break"); __builtin_unreachable(); } while(0)""")

      def visit_endthread(self, et):
            return flatten(et.loc, "goto __sl_end")
            

if __name__ == "__main__":
      source = eval('["""'+sys.stdin.read()+'"""]')

      source = cleanup(source)

      print "##### SOURCE #####"
      pprint.pprint(source)

      print "#### PARSE ####"
      p = parse_program(source)

      print "#### CHECK ####"
      p.accept(DefaultVisitor())

      print "#### PRINT ORIG ####"
      pp = PrinterVisitor()
      p.accept(pp)
      print pp.buffer

      print "#### TFUN -> MTA_TFUN ####"
      pmt = p.accept(TFun_2_MTATFun())
      
      print "#### PRINT MTA_TFUN ####"
      pp = PrinterVisitor()
      pmt.accept(pp)
      print pp.buffer

      print "#### CREATE -> MTA_CREATE ####"
      pmtc = p.accept(Create_2_MTACreate())
      
      print "#### PRINT MTA_CREATE ####"
      pp = PrinterVisitor()
      pmtc.accept(pp)
      print pp.buffer

      
      # print "#### TFUN -> CFUN ####"
      # ps = p.accept(TFun_2_CFun())

      # print "#### PRINT CFUN ####"
      # pp = PrinterVisitor()
      # ps.accept(pp)
      # print pp.buffer

      # print "#### CREATE -> LOOP ####"
      # pc = p.accept(Create_2_Loop())

      # print "#### PRINT LOOP ####"
      # pp = PrinterVisitor()
      # ps.accept(pp)
      # print pp.buffer
