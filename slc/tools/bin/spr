#! /usr/bin/env python
#
# spr: This file is part of the SL toolchain.
#
import sys
import re
import pprint
import copy

from slc.visitors import *
from slc.input.read import read
from slc.input.parse import parse_program
from slc.input.check import CheckVisitor
from slc.lower.seq import *
from slc.lower.lowercreate import *
from slc.lower.split import *
from slc.lower.lowgeta import *
from slc.lower.lowcvars import *
from slc.lower.lowccast import *
from slc.lower.lowclabels import *
from slc.lower.flavorseta import *
from slc.lower.rename import *
from slc.lower.remflavors import *
from slc.mtalpha.visitors import *
from slc.ast import LowCreate

class Dispatcher(object):
      
      def __init__(self, flavored_visitors):
            self.flavored_visitors = flavored_visitors
            for k, v in self.flavored_visitors.items():
                  self.__dict__.update(v.__dict__)
                  v.__dict__ = self.__dict__
                  print "REG V: %x, d = %x" % (id(v), id(v.__dict__))
            self.dispatcher = self
                  
            print self.__dict__
            self.current_flavors = []

      def start_flavor(self, f):
            self.current_flavors.insert(0, f)

      def end_flavor(self, f):
            assert self.current_flavors[0] == f
            self.current_flavors.pop(0)

      def dispatch(self, base_visitor, item, seen_as, *args, **kwargs):
            # here we look up the method in the 
            # flavored visitors first, and fall back
            # to the base visitor if that fails.
            
            methname = 'visit_%s' % seen_as.__name__.lower()
            for f in self.current_flavors:
                  v = self.flavored_visitors.get(f, None)
                  if v is not None:
                        if methname in v.__class__.__dict__:
                              m = getattr(v, methname)
                              return m(item, *args, **kwargs)
            # here, no visitor is found
            m = getattr(base_visitor, methname)
            return m(item, *args, **kwargs)



t = [('walk', DefaultVisitor()),
     ('check', CheckVisitor()),
     ('cr2lc', Create_2_LowCreate()),
     ('splitcr', SplitCreates()),
     ('flseta', FlavorSetA()),
     ('splitfun', SplitFuns()),
     ('flattencr', ScopedVisitor(Dispatcher({'cmta':Create_2_MTACreate(),
                                           'cseq':Create_2_Loop()}))),
     ('flattenfun', DefaultVisitor(Dispatcher({'fmta':TFun_2_MTATFun(),
                                               'fseq':TFun_2_CFun()}))),
     ('geta', ReduceGetA()),
     ('rnlbls', RenameCLabels()),
     ('rnvars', RenameCVars()),
     ('cvars', ReduceCVars()),
     ('ccast', ReduceCCast()),
     ('clabels', ReduceCLabels()),
     ('remflavors', RemoveFlavors()),
     ]

if __name__ == "__main__":

      source = read(sys.stdin)
      tmpfmt = 'tmp.%03dt.%s.c'
      src = 'tmp.000t.c'
      
      
      f = file(src, 'w')
      print >>f, "/* SOURCE */"
      pprint.pprint(source, stream = f)
      f.close()

      p = parse_program(source)

      for (ph, (lbl, visitor)) in enumerate(t):
            print "Applying: %s / %r" % (lbl, visitor)
            p.accept(visitor)

            if lbl == 'check':
                  if visitor.has_errors:
                        sys.exit(1)

            fname = tmpfmt % (ph+1, lbl)
            f = file(fname, 'w')
            print >>f, "/* AFTER %s / %r */" % (lbl, visitor)
            p.accept(PrintVisitor(stream = f))
            f.close()
            print "  -> output: %s" % fname


      
