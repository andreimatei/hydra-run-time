#! /usr/bin/env python
#
# spr: This file is part of the SL toolchain.
#
import sys
import re
import pprint
import copy

from slc.visitors import *
from slc.input.read import read
from slc.input.parse import parse_program
from slc.input.check import CheckVisitor
from slc.lower.seq import *
from slc.lower.lowercreate import *
from slc.lower.split import *
from slc.lower.lowgeta import *
from slc.mtalpha.visitors import *
from slc.ast import LowCreate

class Dispatcher(object):
      
      def __init__(self, flavored_visitors):
            self.flavored_visitors = flavored_visitors
            for k in self.flavored_visitors:
                  self.flavored_visitors[k].dispatcher = self

            self.current_flavors = []

      def start_flavor(self, f):
            self.current_flavors.insert(0, f)

      def end_flavor(self, f):
            assert self.current_flavors[0] == f
            self.current_flavors.pop(0)

      def dispatch(self, base_visitor, item, seen_as, *args, **kwargs):
            # here we look up the method in the 
            # flavored visitors first, and fall back
            # to the base visitor if that fails.
            
            methname = 'visit_%s' % seen_as.__name__.lower()
            for f in self.current_flavors:
                  v = self.flavored_visitors.get(f, None)
                  if v is not None:
                        if methname in v.__class__.__dict__:
                              m = getattr(v, methname)
                              return m(item, *args, **kwargs)
            # here, no visitor is found
            m = getattr(base_visitor, methname)
            return m(item, *args, **kwargs)



if __name__ == "__main__":

      source = read(sys.stdin)

      print "##### SOURCE #####"
      pprint.pprint(source)

      print "#### PARSE ####"
      p = parse_program(source)

      print "#### WALK ####"
      p.accept(DefaultVisitor())

      print "#### CHECK ####"
      cv = CheckVisitor()
      p.accept(cv)
      if cv.has_errors:
            sys.exit(1)

      print "#### PRINT ORIG ####"
      pp = PrinterVisitor()
      p.accept(pp)

      print "#### CREATE -> LOWCREATE ####"
      pc = copy.deepcopy(p)
      pc.accept(Create_2_LowCreate())

      print "#### PRINT LOWCREATE ####"
      pc.accept(pp)

      print "#### LOWCREATE -> SPLIT ####"
      pc.accept(SplitCreates())

      print "#### PRINT SPLIT ####"
      pc.accept(pp)

      print "### FUN -> FSPLIT ###"
      pc.accept(SplitFuns())

      print "### PRINT FSPLIT ###"
      pc.accept(pp)

      print "#### FSPLIT -> MTA_TFUN, CFUN ####"
      pc.accept(DefaultVisitor(Dispatcher({'fmta':TFun_2_MTATFun(),
                                           'fseq':TFun_2_CFun()})))

      print "### PRINT DUAL FUN ###"
      pc.accept(pp)

      print "#### SPLIT -> MTA_CREATE, CLOOP ####"
      pc.accept(DefaultVisitor(Dispatcher({'cmta':Create_2_MTACreate(),
                                           'cseq':Create_2_Loop()})))

      print "#### PRINT DUAL CREATE ####"
      pc.accept(pp)

      print "#### DUAL -> CLEANGETA ####"
      pc.accept(ReduceGetA())

      print "#### PRINT CLEAN ####"
      pc.accept(pp)

      

      #print "#### TFUN -> CFUN ####"
      #ps = copy.deepcopy(p)
      #ps.accept(TFun_2_CFun())

      #print "#### PRINT CFUN ####"
      #ps.accept(pp)

      # print "#### CREATE -> CLOOP ####"
      # pc = copy.deepcopy(p)
      # pc.accept(Create_2_Loop())

      # print "#### PRINT CLOOP ####"
      # pc.accept(pp)

      #print "#### TFUN -> MTA_TFUN ####"
      #pmt = copy.deepcopy(p)
      #pmt.accept(TFun_2_MTATFun())
      
      #print "#### PRINT MTA_TFUN ####"
      #pmt.accept(pp)

      # print "#### CREATE -> MTA_CREATE ####"
      # pmtc = copy.deepcopy(p)
      # pmtc = pmtc.accept(Create_2_MTACreate())
      
      # print "#### PRINT MTA_CREATE ####"
      # pmtc.accept(pp)
      
