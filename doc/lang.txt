=======================
 SL: Language overview
=======================

:Authors: Raphael "kena" Poss
:Date: 2008-03-02

.. contents::

Introduction
============

The new definition of µTC (CSA notes [utc10], [utc11] and others)
breaks compatibility with existing implementations:

- the syntax and semantics proposed are not recognized by the current
  implementation of µtc-ptl;

- the syntax proposed is not recognized by the current core compiler;

- no compiler currently natively recognizes this syntax natively.

In other words our formal definition of a "desired µTC" does not
currently map into a working implementation. However, we recognize the
merits of the existing implementations and we would like to apply the
concepts proposed in [utc10] to the syntax recognized by our current
tools.

For this purpose, we designed a set of preprocessor macros that
reflect the various SVP constructs. These macros are designed so at to
make it possible to propose a different definition (macro expansion)
for each SVP implementation currently worked on.

About the name "SL"
-------------------

The language discussed here was initially dubbed "proto-µTC" and
documented in CSA note [utc17] as a front-end to µTC. However, the
name "proto-µTC" was abandoned for the following reasons:

- the language is not specifically "micro" threaded, so the "µT" part
  in the name would be inaccurate;

- the language does not look nor feel like C, so the "C" part in the
  name would be inaccurate;

- it is really an abstraction of µTC;

- because of the overlap in functionality an utterly clear distinction
  between µTC and this "interface language" is needed for discussions;

- the name µTC is difficult to type, and causes missing letters in PDF
  content tables.

The resulting name "SL" was choosen:

- it can be either be advertised as the "Simple Language", the
  generic "SVP Language", or the "Serendipitous Language" [#]_;

  .. [#] in reference to the accidental discovery of a compilation
     path from this language to assembly which does not require major
     development efforts.

- it contains the minimum number of characters that does not cause
  ambiguity with other uses [#]_.

  .. [#] e.g. ``.s`` as a file name extension already has other uses;
     ``s_`` as a prefix is very likely to be used by existing code.


Implementations
===============

5 different sets of definitions for these macros are implemented:

- a set that translates to the syntax recognized by the current
  GCC-based compiler targeting the Microgrids simulator;

- a set that translates to a mixture of regular C and inline assembly,
  which can be used in combination with a post-compilation to generate
  microthreaded code runnable in the simulator;

- a set that translates to the new syntax proposed in [utc10] and
  other notes;

- a set that translates to the C++ constructs used by µtc-ptl (hereby
  obsoleting the perl script "utc2cpp.pl");

- a set that translates to C constructs that cause the sequential
  execution of a SVP program in a standard C environment (as described
  in CSA note [utc6]).


Example program
===============

The following program creates a family of threads where each thread
identifies itself using a single character and accumulates a
counter. The counter is printed when the thread family has terminated.

Source code::

  m4_include(svp/iomacros.slh)

  sl_def(foo, void, sl_shparm(int, a)) 
  {
     sl_setp(a, sl_getp(a) + 1);
     putc('.');
  } 
  sl_enddef

  sl_def(t_main, void) 
  {
    sl_create(,, 0, 10,,,,
              foo, sl_sharg(int, x));
    sl_seta(x, 0);
    sl_sync();

    printf1("\n%d\n", sl_geta(x));
  } 
  sl_enddef

For some example expansions of this program into actual compilable
code, see `Expansions to existing implementations`_ below.

When this program is run it should produce the following output::

  ..........
  10

About the preprocessor
======================

The preprocessor for the SL language is M4, augmented with the M4
macros from GNU Autoconf's "m4sugar". The C preprocessor features many
not be used.

In order to share data across source files, "header" files as in C can
be simulated with m4's ``m4_include`` and ``m4_ifndef``, as follows::

   // in foo.slh:
   m4_ifndef(FOO_SLH, [[
   m4_define(FOO_SLH,[[]])

   // declarations here
 
   ]])

   // in foo.sl:
   m4_include(foo.slh)

Syntax and semantics
====================

Unless otherwise noted, the semantics for the macros described below
are the same as in the equivalent constructs in the "desired µTC". A
reference expansion for each possible macro call into the "desired
µTC" is given as a specification of semantics.

In particular, thread creation is a declaration for thread arguments
and other objects, as indicated in [utc10].

Types
-----

.. note:: this section needs to be completed to reflect restrictions
   on the use of C's "struct" and "enum".

In the other syntax constructs defined below that accept a type
parameter (e.g. ``sl_glparm``), the type parameter should be
appropriate for use in the "type specifier" syntax location in the C
language.

This excludes in particular array types and function types from being
expressed "in line". For example a parameter that would be otherwise
declared in C as ``int (*f)[10]`` (pointer to an array of 10
``int``'s) should be expressed as follows::

   typedef int (*type_alias)[10];

   ... sl_glparm(type_alias, f) ...

This restriction stems from the fact that the macros will always use
the specified type as a prefix in declarations, and they cannot
construct C's "declarator" notation.

Thread definitions
------------------

The following macros are available:

``sl_def(fname, breakt, args...)``
  Begin a thread function definition.

  The thread function is named ``fname``, with break type ``breakt``
  and parameter list ``args ...``.

  The break type must be either ``void``, ``int`` or ``float``.

  The parameter list may be empty to indicate that the thread function
  does not accept parameters. Otherwise, each item in the parameter
  list must be an invocation of either ``sl_shparm*`` or
  ``sl_glparm*`` (see below).

``sl_shparm(ptype, pname)``, ``sl_shfparm(ptype, pname)``
  Declare a shared parameter with type ``ptype`` and name ``pname``.
  Use the ``f`` variant when using a floating-point type.

``sl_glparm(ptype, pname)``, ``sl_glfparm(ptype, pname)``
  Declare a global parameter with type ``ptype`` and name ``pname``.
  Use the ``f`` variant when using a floating-point type.

``sl_enddef``
  End a thread function definition.

This can be used as follows::

  sl_def(donothing, void, sl_glparm(int, x))
  { }
  sl_enddef

Reference expansion::

  sl_def(fname, breakt, args ...)
  {
    ...
  }
  sl_enddef

  -> thread breakt fname(args ...)
     { 
       ...
     }

  sl_glarg(int, a), sl_shargf(float, b)

  -> /*global*/ int a, shared float b

Thread parameter reads and writes
---------------------------------

The following macros are available:

``sl_getp(name)``, ``sl_getfp(name)``
   Evaluate to the value of parameter ``name``.

   This macro can be used as an expression.
   Use the ``f`` variant when the parameter is of floating-point type.

``sl_setp(name, value)``, ``sl_setfp(name, value)``
   Set the parameter ``name`` to the value of ``value``.

   This macro can be used as a statement.
   Use the ``f`` variant when the parameter is of floating-point type.

This can be used as follows::

  sl_def(adder, void, sl_shparm(int, x))
  { 
    int v = sl_getp(x);
    sl_setp(x, v + 1);
    // or: sl_setp(x, sl_getp(x) + 1);
  }
  sl_enddef

Reference expansion::

  sl_getp(name)

  -> name

  sl_setp(name, value)

  -> name = value

Thread index declaration
------------------------

The following macro is available:

``sl_index(name)``
   Declare the thread index to have name ``name``. 

   The macro should be used at the beginning of a thread body, as
   suggested in CSA note [utc11].

   The index can be used using its name directly, but a cast
   to an integer type may be necessary in some contexts. [#]_

   .. [#] e.g. when passing the index to a macro that may instantiate
      a variable of "the same type"; e.g. ``printf``.

This can be used as follows::

  sl_def(accumulate, void, sl_shared(int, acc))
  {
    sl_index(i);
    sl_setp(acc, sl_getp(acc) + i);
  }
  sl_enddef

Reference expansion::

  sl_index(i)

  -> index i

Thread declarations
-------------------

The following macro is available:

``sl_decl``
  Declare a thread function prototype.

Its syntax is the same as ``sl_def`` presented above, but
``sl_enddef`` is not necessary.

This can be used as follows::

  // declare a thread function (possibly defined elsewhere)
  sl_decl(adder, void, sl_shparm(int, x));

  // make a thread function pointer
  sl_decl((*p), void, sl_shparm(int, x)) = &adder;

  // make a type 
  typedef sl_decl((*tfptr_t), void, sl_shparm(int, x));
  // use the type
  tfptr_t fptr = &adder;

Reference expansion::

  sl_decl(fname, breakt, args ...)
  
  -> thread breakt fname(args ...)

Creating a family of threads
----------------------------

The following macros are available:

``sl_create(lbl,place,start,limit,step,block,breakt,fexp,args ...)``
  Create a family of threads.

  The family is *labeled* by the identifier ``lbl``. ``lbl`` can be
  omitted if the break type is omitted or is ``void``. [#]_

  .. [#] There are no family identifier identifiers (as specified in
     [utc10]) but instead a ``sl_getfid(lbl)`` macro; see below.

  The expression ``place`` is optional.

  The number of threads and their index sequence is defined by the
  values of the (optional) expressions ``start``, ``limit``, ``step``
  and the semantics defined in CSA note [svp14].

  The expression ``block`` is optional.

  The argument ``breakt`` must be either omitted or set to ``void`` if
  the thread function is not breakable; otherwise, it must be set to
  either ``int`` or ``float`` (same as the break type of the thread
  function) and ``lbl`` must be specified as well.

  The expression ``fexp`` must have thread function type.

  The argument list may be empty if the thread function does not
  accept any parameter.  Otherwise, each item in the parameter list
  must be an invocation of either ``sl_sharg*`` or ``sl_glarg*`` (see
  below).

``sl_sharg(atype, aname)``, ``sl_sharg(atype, aname, init)`` 
  Declare a shared thread argument with type ``atype`` and name
  ``aname``.

  The expression ``init`` is optional. If it is present, the argument
  is initialized at the point of declaration with the value of
  ``init``.

  The type ``atype`` must be the same as the corresponding parameter
  type in the thread function prototype.

  Use ``sl_shfarg`` when the argument is of floating-point type.
  

``sl_glarg(atype, aname, init)`` 
  Declare a shared thread argument with type ``atype`` and name
  ``aname``.

  The expression ``init`` is mandatory. The argument is initialized at
  the point of declaration with the value of ``init``.

  The type ``atype`` must be the same as the corresponding parameter
  type in the thread function prototype.

  Use ``sl_glfarg`` when the argument is of floating-point type.

``sl_sync()``, ``sl_sync(lbl)``, ``sl_sync(, lvalue)``, ``sl_sync(lbl, lvalue)``
  Synchronize on the termination of a child family.

  The argument ``lbl`` is present if and only if it is present as 1st
  parameter of the matching ``sl_create``.

  The lvalue expression ``lvalue`` is optional. If it is present, it
  is set to the exit code of the family during synchronization.

This can be used as follows::

  // create an anonymous, non-breakable family of one thread,
  // taking one global argument of type "int" initialized to 0
  sl_create(,,,,,,, 
            donothing, sl_glarg(int, a, 0));
  sl_sync();

  // create a named family of 3 threads, taking a shared
  // argument of type "int" which is not initialized;
  // collect the exit code upon termination:
  int e;
  sl_create(fx,,0,4,1,,,
            adder, sl_sharg(int, b));
  sl_sync(fx, e);
  if (e) ...

Reference expansion::

  sl_create(lbl,pl,be,li,st,bl,bt,
            texp, args ...)

  -> // if bt is "void" or omitted
     create(lbl;pl;be;li;st;bl;) texp(args ...)
  -> // if bt is non-void
     create(lbl;pl;be;li;st;bl;lbl_brk) texp(args ...)
 
  sl_sharg(type, name)

  -> name

  sl_sharg(type, name, init)

  -> name = init

  sl_glarg(type, name, init)

  -> name = init

  sl_sync(lbl)

  -> sync(lbl)

  sl_sync(lbl,value)

  -> value = sync(lbl)

Breaking a family of threads
----------------------------

The following macro is available:

``sl_break(value)``
  Break the current family with value ``value``.

This can be used as follows::

  sl_def(justbreak, int)
  {
     sl_break(10);
  }
  sl_enddef

Reference expansion::

  sl_break(value)

  -> break (value)

Using the objects declared by create
------------------------------------

``sl_getbr(lbl)``
   Evaluate to the break value of the family
   created by the ``sl_create`` construct where ``lbl``
   was specified as 1st parameter.

   This macro can be used as an expression.

   As specified in [utc10] this macro should not be used before
   ``sl_sync``.

``sl_geta(name)``, ``sl_getfa(name)``
   Evaluate to the value of argument ``name``.

   This macro can be used as an expression.
   Use the ``f`` variant when the parameter is of floating-point type.

``sl_seta(name, value)``, ``sl_setfa(name, value)``
   Set the argument ``name`` to the value of ``value``.

   This macro can be used as a statement.
   Use the ``f`` variant when the parameter is of floating-point type.

This can be used as follows::

   int r, b;
   sl_create(fx,,,,,, int,
             justbreak);
   sl_sync(fx, r);
   if (r == EXIT_BROKEN)
      b = sl_getbr(fx);

Reference expansion::

   sl_getbr(lbl)

   -> lbl_brk

   sl_geta(name)

   -> name

   sl_seta(name, value)

   -> name = value

Using the family identifier
---------------------------

The following macros are available:

``sl_getfid(lbl)``
   Evaluate to the family identifier of the family
   created by the ``sl_create`` construct where ``lbl``
   was specified as 1st parameter.

   This macro can be used as an expression.

   As specified in [utc10] this macro should not be used outside of
   the block starting with ``sl_create`` and ending at ``sl_sync``.

   .. note:: this aspect of the language is currently being
      reviewed. The semantics of retrieving the family identifier is
      pending a major change.

``sl_kill(fid)``
   Kill the family identified with ``fid``. 

   The value of ``fid`` must match some previous use of ``sl_getfid``.

This can be used as follows::

  family cf;
  int r;
  sl_create(fx,,,,,,,
            adder, sl_sharg(int, x))
  cf = sl_getfid(fx);
  sl_kill(cf); // or: sl_kill(sl_getfid(fx))
  sl_sync(fx, r);
  if (r == EXIT_KILLED)
      ...

Reference expansion::

  sl_getfid(lbl)

  -> lbl

  sl_kill(fid)

  -> kill(fx)

Expansions to existing implementations
======================================

Expansion for the desired µTC
-----------------------------

The example program given at the start of this note expands as follows
using the desired syntax for µTC::

  thread void count(shared int x)
  {
    x = x + 1;
    putc('.');
  }


  thread void t_main(void)
  {
    create(;;0;10;;;) count(n = 0);
    sync();

    printf1("\n%d\n", n);
  }


Expansion for µtc-ptl
---------------------

The example program given at the start of this note expands as follows
for µtc-ptl::

  void count(uTC::shared<int>& x)
  {
    x = x + 1;
    putc('.');
  }

  void t_main(void)
  {
    family _utlbl_1;   int n = 0; uTC::create(_utlbl_1,PLACE_LOCAL,0,10,1,0, NULL,&(count),&(n));
    uTC::sync(_utlbl_1);

    printf1("\n%d\n", n);
  }

Expansion for the core compiler
-------------------------------

The example program given at the start of this note expands as follows
using the syntax currently accepted by the core compiler::

  thread void count(shared int x)
  {
    x = x + 1;
    putc('.');
  }


  thread void t_main(void)
  {
    register family _utlbl_1;  register int n = 0; create(_utlbl_1;;0;10;;;) count(n );
    sync(_utlbl_1);

    printf1("\n%d\n", n);
  }


Standard library
================

See the separate language specification for details.

