#! /usr/bin/env python
# spp: this file is part of the slc project.
#
# Copyright (C) 2009 Universiteit van Amsterdam..
# All rights reserved.

import pprint
import sys
import subprocess
import re

def die(msg):
   print >>sys.stderr, "%s:" % sys.argv[0], msg
   sys.exit(1)

class NotFound(Exception):
   pass

class pppalpha(object):

   legacy_fregs = {
      # Scratch registers
      'ft0' : 10,
      'ft1' : 11,
      'ft2' : 12,
      'ft3' : 13,
      'ft4' : 14,
      'ft5' : 15,
      'ft6' : 22,
      'ft7' : 23,
      'ft8' : 24,
      'ft9' : 25,
      'ft10' : 26,
      'ft11' : 27,
      'ft12' : 28,
      'ft13' : 29,
      'ft14' : 30,
      # Return value registers
      'frv' : 0,
      'frv2' : 1,
      # Incoming parameters
      'fa0' : 16,
      'fa1' : 17,
      'fa2' : 18,
      'fa3' : 19,
      'fa4' : 20,
      'fa5' : 21,
      # Call-save registers
      'fs0' : 2,
      'fs1' : 3,
      'fs2' : 4,
      'fs3' : 5,
      'fs4' : 6,
      'fs5' : 7,
      'fs6' : 8,
      'fs7' : 9,
      # Zero 
      'fzero' : 31,
      }

   legacy_regs = {
      # function temporaries
      't0' : 1,
      't1' : 2,
      't2' : 3,
      't3' : 4,
      't4' : 5,
      't5' : 6,
      't6' : 7,
      't7' : 8,
      't8' : 22,
      't9' : 23,
      't10' : 24,
      't11' : 25,
      # assembly scratch
      'at' : 28,
      # return value
      'rv' : 0,
      # incoming parameters
      'a5' : 21,
      'a4' : 20,
      'a3' : 19,
      'a2' : 18,
      'a1' : 17,
      'a0' : 16,
      # procedure function / temporary
      'pv' : 27,
      't12' : 27,
      # Callee-save registers
      's0' : 9,
      's1' : 10,
      's2' : 11,
      's3' : 12,
      's4' : 13,
      's5' : 14,
      # Return address
      'ra' : 26,
      # Frame pointer / callee save
      'fp' : 15,
      's6' : 15,
      # Global pointer
      'gp' : 29,
      # Stack pointer
      'sp' : 30,
      # Zero
      'zero' : 31
      }


    ######################
    # GCC Allocation order
    ######################
    # #define REG_ALLOC_ORDER {
    #    1, 2, 3, 4, 5, 6, 7, 8,      /* nonsaved integer registers */
    #    22, 23, 24, 25, 28,          /* likewise */
    #    0,                           /* likewise, but return value */
    #    21, 20, 19, 18, 17, 16,      /* likewise, but input args */
    #    27,                          /* likewise, but OSF procedure value */
    #    f10, f11, f12, f13, f14, f15,      /* nonsaved floating-point registers */
    #    f22, f23, f24, f25, f26, f27,      /* likewise */
    #    f28, f29, f30,                  /* likewise */
    #    f0, f1,                      /* likewise, but return values */
    #    f21, f20, f19, f18, f17, f16,      /* likewise, but input args */
    #    9, 10, 11, 12, 13, 14,       /* saved integer registers */
    #    26,                          /* return address */
    #    15,                          /* hard frame pointer */
    #    f2, f3, f4, f5, f6, f7,      /* saved floating-point registers */
    #    f8, f9,                      /* likewise */
    #    29, 30, 31, f31               /* gp, sp, ap, sfp */
    # }


   reg_mapping = {
      # Globals
      'g0' : 's5',
      'g1' : 's4',
      'g2' : 's3',
      'g3' : 's2',
      'g4' : 's1',
      'g5' : 's0',
      'g6' : 'a0',
      'g7' : 'a1',
      'g8' : 'a2',
      'g9' : 'a3',
      'g10' : 'a4',
      'g11' : 'a5',

      'gf0' : 'fs7',
      'gf1' : 'fs6',
      'gf2' : 'fs5',
      'gf3' : 'fs4',
      'gf4'  : 'fs3',
      'gf5' : 'fs2',
      'gf6' : 'fs1',
      'gf7' : 'fs0',
      'gf8' : 'fa0',
      'gf9' : 'fa1',
      'gf10' : 'fa2',
      'gf11' : 'fa3',
      
      # Shareds
      's0' : 'a5',
      'd0' : 'a4',
      's1' : 'a3',
      'd1' : 'a2',
      's2' : 'a1',
      'd2' : 'a0',
      's3' : 's0',
      'd3' : 's1',
      's4' : 's2',
      'd4' : 's3',

      'sf0' : 'fa3',
      'df0' : 'fa2',
      'sf1' : 'fa1',
      'df1' : 'fa0',
      'sf2' : 'fs0',
      'df2' : 'fs1',
      'sf3' : 'fs2',
      'df3' : 'fs3',
      'sf4' : 'fs4',
      'df4' : 'fs5',
      'sf5' : 'fs6',
      'df5' : 'fs7',
      
      'lf31' : 'fzero',
      
      'lf0' : 'ft0',
      'lf1' : 'ft1',
      'lf2' : 'ft2',
      'lf3' : 'ft3',
      'lf4' : 'ft4',
      'lf5' : 'ft5',
      'lf6' : 'ft6',
      'lf7' : 'ft7',
      'lf8' : 'ft8',
      'lf9' : 'ft9',
      'lf10' : 'ft10',
      'lf11' : 'ft11',
      'lf12' : 'ft12',
      'lf13' : 'ft13',
      'lf14' : 'ft14',
      'lf15' : 'frv',
      'lf16' : 'frv2',
      'lf17' : 'fa4',
      'lf18' : 'fa5',

      # Special locals
      'l31' : 'zero',
      'l18' : 'sp',
      'l17' : 'gp',
      'l16' : 'pv',
      'l15' : 'ra',
      'l14' : 'fp',
      'l13' : 'rv',
      # "Normal" locals
      'l12' : 'at',
      'l11' : 't11',
      'l10' : 't10',
      'l9' : 't9',
      'l8' : 't8',
      'l7' : 't7',
      'l6' : 't6',
      'l5' : 't5',
      'l4' : 't4',
      'l3' : 't3',
      'l2' : 't2',
      'l1' : 't1',
      'l0' : 't0'
      }

   reg_aliases = {
      'tlsp' : 'l18',
      'gp' : 'l17',
      'pv' : 'l16',
      'ra' : 'l15',
      'fp' : 'l14',
      'rv' : 'l13',
      'idx_init' : 'l0',
      'tlsp_init' : 'l1',
      'basearg' : 'l1',
      'zero' : 'l31',
      'fzero' : 'lf31',
      'fbasearg' : 'lf1'
      }

   # Magic numbers
   #iargregs = 6 # 1 reserved for PV
   #fargregs = 4
   iargregs = 11 # 1 reserved for PV
   fargregs = 12

   def __init__(self):
      regs = { 
         'i' : { 'l' : [None]*32, 'g' : [None]*32, 's' : [None]*32, 'd' : [None]*32 },
         'f' : { 'l' : [None]*32, 'g' : [None]*32, 's' : [None]*32, 'd' : [None]*32 },
         }
      reg_inv = map(lambda x:[], xrange(32))
      freg_inv = map(lambda x:[], xrange(32))
      aliases = {}

      for r,t in self.reg_mapping.items():
         cat = r[0]
         if r[1] == 'f':
            species = 'f'
            nr = int(r[2:])
            legnr = self.legacy_fregs[t]
            inv_dic = freg_inv
         else:
            species = 'i'
            nr = int(r[1:])
            legnr = self.legacy_regs[t]
            inv_dic = reg_inv
         
         reg = { 'species' : species, 'cat' : cat, 'name' : r, 'legname' : t, 'nr' : nr, 'legnr' : legnr }
         if aliases.has_key(r):
            die("alias %s already defined" % r)
         aliases[r] = reg
         if regs[species][cat][nr] is not None:
            die("register %s already defined" % r)
         regs[species][cat][nr] = reg
         inv_dic[legnr].append(reg)

      for a,k in self.reg_aliases.items():
         if aliases.has_key(a):
            die("alias %s already defined" % a)
         aliases[a] = aliases[k]
      
      # Consistency check
      for i in reg_inv:
         if len(i) == 0:
            die("all legacy integer registers are not used")
      if i in freg_inv:
         if len(i) == 0:
            die("all legacy fp registers are not used")

      self.reg_inv = reg_inv
      self.freg_inv = freg_inv
      self.regs = regs
      self.aliases = aliases

   def mapcall(self, args):
      dic = { 
         'i' : { 'sh' : [], 'gl' : [] },
         'f' : { 'sh' : [], 'gl' : [] },
         }
      #print args
      for a in args:
         la = a.split(':')
         cat, species, ctype, name = la[:4]
         name = name.strip()
         init = ':'.join(la[4:])
         if init == "":
            init = None
         dic[species][cat].append({'ctype':ctype, 'name':name, 'init':init})

      # Check if some parameters will use memory passing
      escape = 0      
      if len(dic['f']['sh']) * 2 + len(dic['f']['gl']) > self.fargregs:
         escape = 1
      if len(dic['i']['sh']) * 2 + len(dic['i']['gl']) > (self.iargregs - escape):
         escape = 1

      # Start allocate

      islots_avail = self.iargregs - escape
      fslots_avail = self.fargregs

      # Allocate shareds first
      if len(dic['i']['sh']) * 2 > islots_avail:
         die("too many int shareds, cannot pass them via memory yet")
      shc = 0
      for s in dic['i']['sh']:
         s['mode'] = 'reg'
         s['regnr'] = shc
         shc += 1
         islots_avail -= 2
      nrishareds = shc

      if len(dic['f']['sh']) > fslots_avail:
         die("too many float shareds, cannot pass them via memory yet")
      shc = 0
      for s in dic['f']['sh']:
         s['mode'] = 'reg'
         s['regnr'] = shc
         shc += 1
         fslots_avail -= 2
      nrfshareds = shc
   
      # Allocate fp globals
      glc = 0
      memlayout = []
      offset = 0
      for s in dic['f']['gl']:
         if fslots_avail > 0:
            s['mode'] = 'reg'
            s['regnr'] = glc
            glc += 1
            fslots_avail -= 1
         else:
            s['mode'] = 'mem'
            s['offset'] = offset
            offset += 1
            memlayout.append({'cat':'glf','ctype':s['ctype'],'name':s['name'],'init':s['init']})
      nrfglobals = glc

      glc = 0
      for s in dic['i']['gl']:
         if islots_avail > 0:
            s['mode'] = 'reg'
            s['regnr'] = glc
            glc += 1
            islots_avail -= 1
         else:
            s['mode'] = 'mem'
            s['offset'] = offset
            offset += 1
            memlayout.append({'cat':'gli','ctype':s['ctype'],'name':s['name'],'init':s['init']})
      nriglobals = glc

      ret = {}
      if escape == 0:
         ret['gl_mem_offset'] = None
         ret['gl_pv_offset'] = glc
      else:
         nriglobals = glc + 1
         ret['gl_mem_offset'] = glc
         ret['gl_pv_offset'] = glc + 1

      nriglobals = nriglobals + 1 # count PV

      ret['nrargregs'] = { 'gli' : nriglobals, 'shi' : nrishareds,
                           'glf' : nrfglobals, 'shf' : nrfshareds }
      ret['args'] = dic
      ret['memlayout'] = memlayout

      #pprint.pprint(ret)

      return ret

   def create(self, funcname, tag, br, *args):
      # DEBUG:
      #print >>sys.stderr, args
      if len(args) == 1 and args[0] == "":
         args = ()

      c = self.mapcall(args)

      #pprint.pprint(c)

      aliases = self.aliases
      nrargregs = c['nrargregs']

      rregs = []
      wregs = []
      names = []
      glfbase = aliases['fbasearg']['nr']
      shfbase = glfbase + nrargregs['glf']
      glibase = aliases['basearg']['nr']
      shibase = glibase + c['gl_pv_offset'] + 1
      if br == "float":
         brf = shfbase + nrargregs['shf']
         cri = shibase + nrargregs['shi']
      elif br == "int":
         bri = shibase + nrargregs['shi']
         cri = bri + 1
      else: # no break
         cri = shibase + nrargregs['shi']

      print "__sl_allocate(%s, %d, %d, %d, %d);" % \
          (tag, glibase, shibase, glfbase, shfbase)


      for species,d1 in c['args'].items():
         for cat,d2 in d1.items():
            for a in d2:
               name = a['name']
               names.append(name)
               ctype = a['ctype']
               if a['mode'] == 'mem':
                  assert cat == 'gl'
                  print "__sl_declgla_noreg(%s, %s, %s);" % (ctype, name, a['init'])
                  print "m4_pushdef([[__sl_geta_%s]],[[__sl_arg_%s]])m4_dnl" % (name,name)
                  print "m4_pushdef([[__sl_seta_%s]],[[\n#error cannot set global %s\n]])m4_dnl" % (name, name)
               else: # mode: reg
                  regnr = a['regnr']
                  if cat == "sh":
                     if species == "f":
                        reg = "f%d" % aliases['lf%d' % (shfbase + regnr)]['legnr']
                     else:
                        reg = "%d" % aliases['l%d' % (shibase + regnr)]['legnr']
                        
                     if a['init'] is None:
                        print '__sl_declsha_empty(%s, %s, "$%s");' % (ctype, name, reg)
                     else:
                        print '__sl_declsha(%s, %s, "$%s", %s);' % (ctype, name, reg, a['init'])
                     wregs.append('__sl_arg_%s' % name)
                     print 'm4_pushdef([[__sl_geta_%s]],[[__sl_getsha(%s)]])m4_dnl' % (name, name)
                     print 'm4_pushdef([[__sl_seta_%s]],[[__sl_setsha(%s, [[$1]])]])m4_dnl' % (name, name)
                     #print 'm4_pushdef([[__sl_geta_%s]],[[__sl_arg_%s]]) m4_dnl' % (name, name)
                     #print 'm4_pushdef([[__sl_seta_%s]],[[__sl_arg_%s = [[$1]]]]) m4_dnl' % (name, name)
                  else: # cat: gl
                     if species == "f":
                        reg = "f%d" % aliases['lf%d' % (glfbase + regnr)]['legnr']
                     else:
                        reg = "%d" % aliases['l%d' % (glibase + regnr)]['legnr']
                     rregs.append('__sl_arg_%s' % name)
                     print '__sl_declgla(%s, %s, "$%s", %s);' % (ctype, name, reg, a['init'])
                     print 'm4_pushdef([[__sl_geta_%s]],[[__sl_arg_%s]])m4_dnl' % (name, name)
                     print "m4_pushdef([[__sl_seta_%s]],[[\n#error cannot set global %s\n]])m4_dnl" % (name, name)

      pvreg = str(aliases['l%d' % (glibase + c['gl_pv_offset'])]['legnr'])
      print '__sl_declgla(__sl_fptr_t, __fptr%s, "$%s", %s);' % (tag, pvreg, funcname)

      if c['gl_mem_offset'] is not None:
         print "volatile struct __sl_ma_t_%s {" % tag
         for d in c['memlayout']:
            print d['ctype'], d['name'], ';'
         print '} __sl_ma_data_%s;' % tag
         for d in c['memlayout']:
            print '__sl_ma_data_%s.%s = __sl_arg_%s;' % (tag, d['name'], d['name'])

         
         nr = aliases['basearg']['nr'] + c['gl_mem_offset']
         reg = aliases['l%d' % nr]['legnr']
         print "register volatile const struct __sl_ma_t_%s" % tag, \
             '* __restrict__ const __sl_ma_p_%s __asm__("$%d")' % (tag, reg), \
             "= &__sl_ma_data_%s;" % tag

         rregs.append('__sl_ma_p_%s' % tag)

      if br == 'int':
         brreg = aliases['l%d' % bri]['legnr']
         print '__sl_setbreak(%s, %d);' % (tag, bri)
         print '__sl_declbr(%s, long long, "$%d");' % (tag, brreg)
         wregs.append('__sl_br_%s' % tag)
      elif br == 'float':
         brreg = aliases['lf%d' % brf]['legnr']
         print '__sl_setbreakf(%s, %d);' % (tag, brf)
         print '__sl_declbr(%s, double, "$f%d");' % (tag, brreg)
         wregs.append('__sl_br_%s' % tag)

      print """
      __sl_setplace(__sl_tag, _sl_place);
      __sl_setstart(__sl_tag, _sl_start);
      __sl_setlimit(__sl_tag, _sl_limit);
      __sl_setstep(__sl_tag, _sl_step);
      __sl_setblock(__sl_tag, _sl_block);
      """

      crreg = aliases['l%d' % cri]['legnr']
      print '__sl_declsync(%s, "$%d");' % (tag, crreg)
      

      rregs.append('__sl_arg___fptr%s' % tag)
      wregs1 = ['__sl_sync_%s' % tag] + wregs
      wqueue_cre = ", ".join(['"=rf"(%s)' % x for x in wregs1])
      rqueue_cre = ", ".join(['"%d"(%s)' % i for i in enumerate(wregs1)] + ['"rf"(%s)' % x for x in rregs])
      print '__asm__ __volatile__("crei %%0, 0(%%%d)\t# CREATE %s" : %s : %s);' % \
                                (2*len(wregs1)+len(rregs)-1, tag, wqueue_cre, rqueue_cre)

      wqueue_sync = ", ".join(['"=rf"(%s)' % x for x in wregs])
      rqueue_sync = ", ".join(['"%d"(%s)' % i for i in enumerate(wregs)] + ['"rf"(%s)' % x for x in rregs])
      print "m4_define([[__sl_rqueue_sync]],[[%s]])" % rqueue_sync
      print "m4_define([[__sl_nrwrites]],[[%d]])" % len(wregs)
      print "m4_define([[__sl_wqueue_sync]],[[%s]])" % wqueue_sync
      
   def fundef(self, funcname, counter, *args):

      # DEBUG:
      #print >>sys.stderr, args
      if len(args) == 1 and args[0] == "":
         args = ()

      c = self.mapcall(args)

      mapping = []

      aliases = self.aliases
      print '__sl_prologue(%s, %d, %d, %d, %d, "$%d", %s)' % \
          (funcname, \
              c['nrargregs']['gli'], \
              c['nrargregs']['shi'], \
              c['nrargregs']['glf'], \
              c['nrargregs']['shf'], \
              aliases['idx_init']['legnr'], \
              counter)
      
      # DEBUG:
      #pprint.pprint(c)

      if c['gl_mem_offset'] is not None:
         glreg = 'g%d' % c['gl_mem_offset']
         legnr = aliases[glreg]['legnr']
         mapping.append("%d:%s" % (legnr, glreg))
         print "register const struct {"
         for d in c['memlayout']:
            print d['ctype'], d['name'], ';'
         print '} * __restrict__ const __sl_ma __asm__("$%d");' % legnr
      
      names = []
      for species,d1 in c['args'].items():
         for cat,d2 in d1.items():
            for a in d2:
               name = a['name']
               names.append(name)
               ctype = a['ctype']
               if a['mode'] == 'mem':
                  assert cat == 'gl'
                  print "m4_define([[__sl_getp_%s]],[[(__sl_ma->%s)]])m4_dnl" % (name,name)
                  print "m4_define([[__sl_setp_%s]],[[\n#error cannot set global %s\n]])m4_dnl" % (name, name)
               else: # mode: reg
                  regnr = a['regnr']
                  if cat == "sh":
                     if species == "f":
                        dreg = "df%d" % regnr
                        dlegnr = aliases[dreg]['legnr']
                        sreg = "sf%d" % regnr
                        slegnr = aliases[sreg]['legnr']
                        leg1 = "f%d" % dlegnr
                        leg2 = "f%d" % slegnr
                     else:
                        dreg = "d%d" % regnr
                        dlegnr = aliases[dreg]['legnr']
                        sreg = "s%d" % regnr
                        slegnr = aliases[sreg]['legnr']
                        leg1 = "%d" % dlegnr
                        leg2 = "%d" % slegnr
                     mapping.append("%d:%s" % (dlegnr, dreg))
                     mapping.append("%d:%s" % (slegnr, sreg))
                     
                     print '__sl_declshp(%s, %s, "$%s", "$%s");' % (ctype, name, leg1, leg2)
                     print 'm4_define([[__sl_getp_%s]],[[__sl_getshp(%s)]])m4_dnl' % (name, name)
                     print 'm4_define([[__sl_setp_%s]],[[__sl_setshp(%s, [[$1]])]])m4_dnl' % (name, name)
                  else: # cat: gl
                     if species == "f":
                        reg = "gf%d" % regnr
                        legnr = aliases[reg]['legnr']
                        leg = "f%d" % legnr
                     else:
                        reg = "g%d" % regnr
                        legnr = aliases[reg]['legnr']
                        leg = "%d" % legnr
                     mapping.append("%d:%s" % (legnr, reg))

                     print '__sl_declglp(%s, %s, "$%s");' % (ctype, name, leg)
                     print 'm4_define([[__sl_getp_%s]],[[__sl_glparm_%s]])m4_dnl' % (name, name)
                     print "m4_define([[__sl_setp_%s]],[[\n#error cannot set global %s\n]])m4_dnl" % (name, name)
      print "m4_define([[__sl_parmnames]],[[%s]])m4_dnl" % ','.join(names)
      print 'm4_define([[__sl_parmspec]],[["%s"]])m4_dnl' % ','.join(mapping)

   def compile(self, arch, compiler, *args):
      """ Run the compiler, adding special flags to fix registers """

      # Add flags to reserve all registers that may be used
      # for shareds, globals and dependents:
      fargs = []
      for (v,l) in [("f",self.freg_inv), ("",self.reg_inv)]:
         fixed = set()
         for rl in l:
            for r in rl:
               if r['cat'] in 'sdg':
                  fixed.add(r['legnr'])
         for r in fixed:
            fargs.append('-ffixed-$%s%d' % (v,r))
      # Indicate to GCC it does not need to save
      # RA before it uses it:
      fargs.append('-fcall-saved-$%d' % self.aliases["ra"]['legnr'])

      cmd = [compiler] + fargs + list(args) # + ['-fverbose-asm']
      try:         
         retcode = subprocess.call(cmd)
         sys.exit(retcode)
      except Exception, e:
         #print >>sys.stderr, sys.argv[0] + ':', ' '.join(cmd)
         print >>sys.stderr, sys.argv[0] + ': %s: %r' % (compiler, e)
         sys.exit(126)



   def makerepl(self, gli, shi, glf, shf):
      """ 
      Create a substitution function suitable for re.sub,
      based on the values given to .registers.
      """

      subst = {}
      regs = self.regs
      for (spec, cat, nr, pref) in [('i','d',shi, ''),('i','s',shi, ''),('i','g',gli, ''),
                                    ('f','d',shf, 'f'),('f','s',shf, 'f'),('f','g',glf, 'f')]:
         for i in xrange(nr):
            r = regs[spec][cat][i]
            key = "%s%d" % (pref,r['legnr'])
            assert not subst.has_key(key)
            subst[key] = r['name']
      for (spec, pref) in [('i',''),('f','f')]:
         for r in (r for r in regs[spec]['l'] if r is not None):
            key = "%s%d" % (pref,r['legnr'])
            assert not subst.has_key(key)
            subst[key] = r['name']

      def repl(match):
         r = match.group(1)
         #if r == "$31" or r == "$f31":
         #   return r
         return '$' + subst[r[1:]]
      
      return repl

   ###
   ### Filtering stages: use Python generators!
   ###

   def reader(self, inname):
      """
      Read a file line by line, produce a generator of lines.
      """
      try:
         inf = file(inname)
      except Exception, e:
         print >>sys.stderr, sys.argv[0] + ':', inname, ': %r' % e
         sys.exit(1)
      for line in (line.rstrip() for line in inf):
         yield line
      inf.close()

   def lexer(self, lines):
      """
      Split code from comments, produce a generator of (code, comment).
      """
      #w = re.compile(r'\s+')
      r = re.compile(r'([^#]*)((#.*)?)')
      for line in lines:
         #wline = w.sub(' ', line)
         #m = r.match(wline)
         m = r.match(line)
         asm = m.group(1).strip()
         comment = m.group(2)
         if comment is None:
            comment = ''
         else:
            comment = comment[1:].strip()
         yield (asm, comment)

   def parser(self, tokens):
      """
      Recognize assembly lines, produce a generator of (type, code, comment).
      Type can be "directive", "empty", "label", "other".
      """

      relabel = re.compile(r'[^:]+:')
      redir = re.compile(r'\.[a-z]+')

      for (asm, comment) in tokens:
         if not asm:
            yield ('empty', asm, comment)
         elif relabel.match(asm):
            yield ('label', asm, comment)
         elif redir.match(asm):
            yield ('directive', asm, comment)
         else:
            yield ('other', asm, comment)

   def munchret(self, fundata, items):
      """
      Replace ret and possible frame adjustment by end thread
      """
      spreg = self.legacy_regs['sp']
      gpreg = self.legacy_regs['gp']
      rareg = self.legacy_regs['ra']
      fpreg = self.legacy_regs['fp']
      reanyreg = r'(\$f?\d+)'
      respecial = r'(\$(%d|%d|%d|%d))' % (spreg, gpreg, rareg, fpreg)
      rekill = r'(mov %s,\s*\$%d|ld. %s,\d+\(\$%d\))' % (reanyreg, spreg, respecial, spreg)
      rekill = re.compile(rekill)

      queue = []
      for (i, (type, content, comment)) in enumerate(items):
         if content.startswith('ret '):
            hello = 1
            qnew = []
            while hello:
               if len(queue) == 0:
                  hello = 0
               else:
                  r = queue[-1][1]
                  if rekill.match(r):
                     qnew.insert(0,r)
                     queue.pop()
                  else:
                     hello = 0
            for r in qnew:
               queue.append(('empty','','MT: optimized away: %s' % r))
            queue.append(('other','nop','END_THREAD'))
            queue.append(('other','end','END_THREAD'))
         else:
            queue.append((type, content, comment))

      return queue
            
            

   def detectregs(self, fundata, items):
      """
      Check if GP, SP, PV are used (in case they need to be initialized...)
      """
      use_sp = 0
      spreg = '$%d' % self.legacy_regs['sp']
      use_gp = 0
      gpreg = '$%d' % self.legacy_regs['gp']
      use_pv = 0
      pvreg = '$%d' % self.legacy_regs['pv']
      for (type, content, comment) in items:
         if type == 'other':
            if spreg in content:
               use_sp = 1
            elif gpreg in content:
               use_gp = 1
            elif ('jsr' in content) and (pvreg in content):
               use_pv = 1
         yield (type, content, comment)
      fundata['use_sp'] = use_sp
      fundata['use_gp'] = use_gp
      fundata['use_pv'] = use_pv

   def xjoin1(self, fundata, items):
      """
      Rebuild function code back into a single body.
      """
      name = fundata['name']
      for n in fundata['pprologue']:
         yield n
      yield ('label', '$%s..ng:' % name, '')
      for n in fundata['prologue']:
         yield n
      yield ('directive', '.prologue %d' % (fundata['prologuen']), '')
      for n in items:
         yield n

   def xjoin2(self, fundata, items):
      """
      Add function header.
      """
      name = fundata['name']
      regs = fundata['regs']
      yield ('directive', '.globl %s' % name, '')
      yield ('directive', '.ent %s' % name, '')
      yield ('label', '%s:' % name, '')
      yield ('directive', '.registers %d %d %d %d %d %d' % tuple(regs), '')
      for n in items:
         yield n
      yield ('directive', '.end %s' % name, '')     


   def flattener(self, items):
      """
      Flatten function code back into single stream.
      Produce a generator of (type, code, comment)
      """
      for (type, content, comment) in items:
         if type == "fun":
            for i in content['body']:
               yield i
         else:
            yield (type, content, comment)

   def grouper(self, items):
      """
      Group function code together (when applicable).
      Produce a generator of (type, code, comment).

      For functions, emit a single item with type == "fun". In this case
      code is a dictionary with keys:
      - "name" : name of the function
      - "body" : stream of instructions
      """

      state = 0
      queue = []

      for (type, content, comment) in items:
         if state == 0:
            # expect: .globl _x_...
            if content.startswith('.globl'):
               name = content.split(' ')[1]
               if name.startswith('_x_'):
                  state += 1
                  queue.append((type, content, comment))
                  continue
         elif state == 1:
            # expect: .ent _x_...
            if content.startswith('.ent'):
               maybe_name = content.split(' ')[1]
               if maybe_name == name:
                  state += 1
                  queue.append((type, content, comment))
                  continue
         elif state == 2:
            # expect: stuff, then .end _x_...
            queue.append((type, content, comment))
            if not content.startswith('.end'):
               continue
            maybe_name = content.split(' ')[1]
            if maybe_name == name:
               state = 0
               yield ('fun',{'name':name[3:],'body':queue, 'prologue':[], 'pprologue':[],'prologuen':0},'')
               queue = []
               continue

         for q in queue:
            yield q
         queue = []
         state = 0
         yield (type, content, comment)

   def funfilter(self, filter, items):
      for (type, content, comment) in items:
         if type == 'fun':
            #print "XXXXXXXXXXXXXXXXXXXXXX"
            #print filter
            #pprint.pprint(content)
            content['body'] = [x for x in filter(content, content['body'])]
            #pprint.pprint(content)
         yield (type, content, comment)

   def xsplit(self, fundata, items):
      name = fundata['name']
      inprologue = 0
      inpprologue = 0
      for (type, content, comment) in items:
         if content.startswith('.frame ') \
                or content.startswith('.mask ') \
                or content.startswith('.globl ') \
                or content.startswith('.ent ') \
                or content.startswith('.end '):
            continue
         elif type == 'label' and content == ('$_x_%s..ng:' % name):
            inpprologue = 0
            inprologue = 1
            continue
         elif inprologue == 1:
            if type == 'label' and content == ('_x_%s:' % name):
               continue
            elif content.startswith('.prologue'):
               fundata['prologuen'] = int(content.split(' ')[1])
               inprologue = 0
               continue
            fundata['prologue'].append((type, content, comment))
            continue
         elif type == 'label' and content == ('_x_%s:' % name):
            inpprologue = 1
            continue
         elif inpprologue == 1:
            fundata['pprologue'].append((type, content, comment))
            continue
         
         yield (type, content, comment)
            

   def regextract(self, fundata, items):
      reregs = re.compile(r'.registers (\d+) (\d+) (\d+) (\d+) (\d+) (\d+)')
      for (type, content, comment) in items:
         m = reregs.match(content)
         if m is not None:
            assert not fundata.has_key('regs')
            fundata['regs'] = [int(x) for x in m.groups()]
            continue

         yield (type, content, comment)
   
   def remdefaults(self, fundata, items):
      resp = re.compile(r'setplace \$l\d+, 1$')
      resb = re.compile(r'setstart \$l\d+, 0$')
      resl = re.compile(r'setlimit \$l\d+, 1$')
      ress = re.compile(r'setstep \$l\d+, 1$')
      resbl = re.compile(r'setblock \$l\d+, 0$')
      for (type, content, comment) in items:
         if type == 'other' and \
            (resp.match(content) is not None \
                   or resb.match(content) is not None \
                   or resl.match(content) is not None \
                   or ress.match(content) is not None \
                   or resbl.match(content) is not None):
               # default setting, ignore
            yield ('empty','','MT: "%s" ignored (uses default) %s' % (content,comment))
            continue
         yield (type, content, comment)

   def rmdupswch(self, fundata, items):
      seeswch = 0
      for (type, content, comment) in items:
         if type == 'other':
            if content.startswith('swch'):
               if seeswch == 0:
                  seeswch = 1
                  yield (type, content, comment)
            else:
               seeswch = 0
               yield (type, content, comment)
         else:
            yield (type, content, comment)


   def barkatjsr(self, fundata, items):
      for (type, content, comment) in items:
         if type == "other" and content.startswith('jsr'):
            die("%s: unsupported call: %s" % (fundata['name'],content))
         yield (type, content, comment)
         

   def renameregs(self, fundata, items):
      rd = fundata['regs']
      repl = self.makerepl(rd[0],rd[1],rd[3],rd[4])
      re1reg = re.compile('(\$f?\d+)')
      for (type, content, comment) in items:
         content = re1reg.sub(repl, content)
         comment = re1reg.sub(repl, comment)
         yield (type, content, comment)

   def forcezero(self, items):
      for (type, content, comment) in items:
         content = content.replace('$l31','$31').replace('$lf31','$f31')
         yield (type, content, comment)
         
   def seereg(self, reg, str):
      r = re.compile(r'\$[ld]f?\d+')
      for m in r.findall(str):
         if m == reg:
            return True
      return False

   def markused(self, fundata, items):
      r1 = re.compile(r'\$l(\d+)')
      r2 = re.compile(r'\$lf(\d+)')
      r3 = re.compile(r'\$g(\d+)')
      r4 = re.compile(r'\$gf(\d+)')
      rmask = [False] * 32
      rfmask = [False] * 32
      rgmask = [False] * 32
      rgfmask = [False] * 32
      for (type, content, comment) in items:
         if type == 'other':
            for rm in r1.finditer(content):
               n = int(rm.group(1))
               rmask[n] = True
            for rm in r2.finditer(content):
               n = int(rm.group(1))
               rfmask[n] = True
            for rm in r3.finditer(content):
               n = int(rm.group(1))
               rgmask[n] = True
            for rm in r4.finditer(content):
               n = int(rm.group(1))
               rgfmask[n] = True
         yield (type, content, comment)
      fundata['usedregs'] = rmask
      fundata['usedfregs'] = rfmask
      fundata['usedgl'] = rgmask
      fundata['usedglf'] = rgfmask


   def makespecialtransform(self, special):
      def dotransform(fundata, items):
         nr = int(self.reg_aliases[special][1:])
         regname = '$l%d' % nr
         rmask = fundata['usedregs']
         dorename = 0
         if rmask[nr] == True and False in rmask:
            freenr = [i for (i,r) in enumerate(rmask) if r == False][0]
            dorename = 1
            newname = '$l%d' % freenr
            rmask[nr] = False
            rmask[freenr] = True
            yield ('empty','','MT: special "%s" renamed from %s to %s' % (special, regname, newname))
         for (type, content, comment) in items:
            if type == 'other' and dorename == 1:
               content = content.replace(regname, newname)
            yield (type, content, comment)
      return dotransform

   def compress(self, fundata, items):

      regs = fundata['regs']
      rmask = fundata['usedregs']
      rfmask = fundata['usedfregs']
      rgmask = fundata['usedgl']
      rgfmask = fundata['usedglf']

      # Compress integer locals
      lastfound = None
      for i in xrange(30, -1, -1):
         if rmask[i]:
            lastfound = i
            break
      if lastfound is None:
         newnr = 0
      else:
         newnr = lastfound + 1
         
      # FIXME: WORKAROUND BUG IN SIMULATOR
      if newnr < 2:
         newnr = 2

      if newnr < regs[2]:
         yield ('empty','','MT: compressed integer locals from %d to %d' % (regs[2], newnr))
         regs[2] = newnr

      # Compress integer globals
      lastfound = None
      for i in xrange(30, -1, -1):
         if rgmask[i]:
            lastfound = i
            break
      if lastfound is None:
         newnr = 0
      else:
         newnr = lastfound + 1
      if newnr < regs[0]:
         yield ('empty','','MT: compressed integer globals from %d to %d' % (regs[0], newnr))
         regs[0] = newnr

      # Compress FP locals
      lastfound = None
      for i in xrange(30, -1, -1):
         if rfmask[i]:
            lastfound = i
            break
      if lastfound is None:
         newnr = 0
      else:
         newnr = lastfound + 1
      if newnr < regs[5]:
         yield ('empty','','MT: compressed FP locals from %d to %d' % (regs[5], newnr))
         regs[5] = newnr

      # Compress FP globals
      lastfound = None
      for i in xrange(30, -1, -1):
         if rgfmask[i]:
            lastfound = i
            break
      if lastfound is None:
         newnr = 0
      else:
         newnr = lastfound + 1
      if newnr < regs[3]:
         yield ('empty','','MT: compressed FP globals from %d to %d' % (regs[3], newnr))
         regs[3] = newnr

      for (type, content, comment) in items:
         yield (type, content, comment)

   def addswchll(self, fundata, items):
      re3way = re.compile(r'\w+\s([^,]+),([^,]+),([^,]+)$')
      re1way = re.compile(r'\w+\s([^,]+)$')
      re2way = re.compile(r'mov\s([^,]+),([^,]+)$')
      rexway = re.compile(r'\w+\s([^,]+),(.*)')
      reld = re.compile(r'(ld[lqts]|allocate)')
      re3wayll = re.compile(r'(add|sub|mul|div|sqrt)[ts]')

      allregs = ['$l%d' % x for x in xrange(31 - self.iargregs) if x not in (17, 18)] + \
          ['$lf%d' % x for x in xrange(31 - self.fargregs)] + \
          ['$d%d' % x for x in xrange(self.iargregs / 2)] + \
          ['$df%d' % x for x in xrange(self.fargregs / 2)]
         
      # initially exlude index and sp reg
      maybell = [x for x in list(allregs) if x not in ["$l0", "$l1"]] 

      for (type, content, comment) in items:
         yield (type, content, comment)
         if type == 'label':
            maybell = list(allregs)

         elif type == 'other':
            reads = []
            shortwrites = []
            longwrites = []
            done = 0


            # check 3-way insns
            m = re3way.match(content)
            if m is not None and not done:
               r1, r2, r3 = m.groups()
               reads.append(r1)
               reads.append(r2)
               if re3wayll.match(content) is None:
                  shortwrites.append(r3)
               else:
                  longwrites.append(r3)
               done = 1


            # check 1-way insn, 1st is target (e.g. break)
            m = re1way.match(content)
            if m is not None and not done:
               r1 = m.group(1)
               if content.startswith('setempty'):
                  shortwrites.append(r1)
               else:
                  reads.append(r1)
               done = 1


            # check 2-way insn, second is target (e.g. mov)
            m = re2way.match(content)
            if m is not None and not done:
               r1, r2 = m.groups()
               reads.append(r1)
               shortwrites.append(r2)
               done = 1

       
            # check other insns, assume 1st is target
            m = rexway.match(content)
            if m is not None and not done:
               r1, r2 = m.groups()
               reads.append(r2)

               # Special case for loads from memory:
               m2 = reld.match(content)
               if m2 is not None:
                  longwrites.append(r1)
               elif content.startswith('lda'):
                  shortwrites.append(r1)
               elif content.startswith('cred') or content.startswith('crei'):
                  longwrites.append(r1)
                  reads.append(r1)
               else:
                  # insn reads 1st operand, then writes to it
                  reads.append(r1)
                  shortwrites.append(r1)
            
            test = 0
            q = []

            # if one of the "maybe regs" is read from,
            # assume we are reading result from long latency.
            for rx in maybell:
               for r in reads:
                  if self.seereg(rx,r):
                     test = 1
                     q.append(rx)
            if test == 1:
               yield ('other','swch','MT: prev insn may read result of long latency op (%s)' % ','.join(q))

            # all the registers that are "short written"
            # will not cause long latency during next use
            for rx in maybell:
               for r in shortwrites:
                  if self.seereg(rx, r):
                     q.append(rx)

            # remove touched registers from the long latency registers
            for r in q:
               maybell = [x for x in maybell if x != r]
            # add generated long latency
            for rx in allregs:
               for r in longwrites:
                  if self.seereg(rx, r):
                     maybell.append(rx)
            

   def addswchbr(self, fundata, items):
      rebr = re.compile(r'f?(br|beq|bne|bge|ble|bgt|blt)\s')
      for (type, content, comment) in items:
         yield (type, content, comment)
         if rebr.match(content) is not None:
            yield ('other','swch','MT: swch after branch')

   def addswchdep(self, fundata, items):
      redeps = re.compile(r'.*\$df?\d+')
      for (type, content, comment) in items:
         yield (type, content, comment)
         if redeps.match(content) is not None:
            yield ('other','swch','MT: previous insn reads dependent')

   def makespecial(self, fundata, items):
      gli, shi, li, glf, shf, lf = fundata['regs']
      assert gli > 0
      assert li > 3
      pvargreg = gli - 1
      pvreg = li - 3
      gpreg = li - 2
      spreg = li - 1
      pprologue = fundata['pprologue']
      if fundata['use_gp']:
         # GP needs to be initialized, do it:
         assert len(pprologue) == 2
         disp = pprologue[0][1].split('!')[2]
         fundata['pprologue'] = [('other','ldah $l%d, 0($g%d) !gpdisp!%s' % (gpreg, pvargreg, disp),''),
                                 ('other','lda $l%d, 0($l%d) !gpdisp!%s' % (gpreg, gpreg, disp),'')]
      else:
         assert len(pprologue) == 0
      if fundata['use_pv']:
         fundata['prologue'].insert(0, ('other','mov $g%d, $l%d' % (pvargreg, pvreg), ''))
      if fundata['use_sp'] and spreg != 1:
         fundata['prologue'].insert(0, ('other','mov $l1, $l%d' % spreg,''))

      return items

   def printer(self, items):
      for (type, content, comment) in items:
         if comment:
            tail = "# %s" % comment
         else:
            tail = ""
         if type == "label":
            head = '%s ' % content
         elif content:
            head = '\t%s\t\t' % content
         else:
            head = ''
         yield '%s%s\n' % (head, tail)

   def filter(self, arch, compiler, output, *inputs):

      try:
         outf = file(output, "w")
      except Exception, e:
         print >>sys.stderr, sys.argv[0] + ':', output, ': %r' % e
         sys.exit(1)

      for inname in inputs:
         lines = self.reader(inname)
         tokens = self.lexer(lines)
         items = self.parser(tokens)
         groups = self.grouper(items)
         groups = self.funfilter(self.barkatjsr, groups)
         groups = self.funfilter(self.detectregs, groups)
         groups = self.funfilter(self.regextract, groups)
         groups = self.funfilter(self.munchret, groups)
         groups = self.funfilter(self.renameregs, groups)
         groups = self.funfilter(self.xsplit, groups)
         groups = self.funfilter(self.makespecial, groups)
         groups = self.funfilter(self.remdefaults, groups)
         groups = self.funfilter(self.addswchll, groups)
         # groups = self.funfilter(self.addswchdep, groups)
         groups = self.funfilter(self.addswchbr, groups)
         groups = self.funfilter(self.rmdupswch, groups)

         groups = self.funfilter(self.xjoin1, groups)
         groups = self.funfilter(self.markused, groups)
         groups = self.funfilter(self.makespecialtransform('gp'), groups)
         groups = self.funfilter(self.makespecialtransform('tlsp'), groups)
         groups = self.funfilter(self.compress, groups)
         groups = self.funfilter(self.xjoin2, groups)
         items = self.flattener(groups)
         items = self.forcezero(items)
         lines = self.printer(items)
         for line in lines:
            # print "YOO:", line,
            outf.write(line)


      outf.close()

if __name__ == "__main__":
   module = sys.argv[1]
   function = sys.argv[2]
   rest = sys.argv[3:]
   c = eval(module + "()")
   getattr(c,function)(*rest)

