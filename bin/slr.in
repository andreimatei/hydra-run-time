#! @BASH@
#
# slr: This file is part of the SL toolchain.
#
copyright="Copyright (C) 2009 Universiteit van Amsterdam."
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version.
#
# The complete GNU General Public Licence Notice can be found as the
# `COPYING' file in the root directory.
#
# $Id$
#
set -e
python=${PYTHON:-@python@}
slc_helper=${SLC:-@slc_helper@}
sag_helper=${SAG:-@sag_helper@}
slc_libdir=${SLC_LIBDIR:-@slc_libdir@}
slc_datadir=${SLC_DATADIR:-@slc_datadir@}
TMPDIR=${TMPDIR:-/tmp}

version=@slc_version@
slrev=@slc_revision@
bugreports=@bugreports@

do_usage() {
  cat <<EOF
SL Runner.

The \`slr' utility provides a single interface to run a SVP program
compiled with \`slc'. \`slr' analyses the executable file to determine
how to run the program, and invokes the simulator if needed.

This uses the SL input mechanism described in CSA note [sl3].

Usage: $0 [OPTION] PROGRAM [ARGS]...

Options:
  -dVAR                Define the program input VAR as an empty array.

  -dVAR=..., VAR=...   Define the program input VAR as specified (see 
                       CSA note [sl3] for details).

  -l                   List variables required as input by the program.

  -c                   Show configuration string embedded in program, if any.

  -r runner            Use the specified runner (use when autodetect fails).

  -Ws,arg              Pass "arg" as extra command line parameter to the 
                       simulator, when the simulator is used.

  -x                   Trace: print commands before running them.

  -g                   Debug: try to run debugger around program. Implies -x.

  -h, --help           Print this help, then exit.

  -v, --version        Print version number, then exit.

Environment variables:
  VERBOSE              If set and not empty, implies option -x.

  DEBUG                If set and not empty, implies option -g.

  DEBUGGER             Command prefix to use as debugger. 
                       Default is \`gdb --args'.

  SIMARGS              Combines with the occurrences of option -Ws on
                       the command line when running the simulator.

Examples:

  \$ slr -c a.out 

  Shows runner string stored in \`a.out'.

  \$ slr fibo.x -dN=15

  Runs fibo.x, possibly using the MT simulator, and set program input
  variable N to an array of 1 element with value "15".

  \$ slr fibo.x -dN=10 -Ws,-o -Ws,NumProcessors=7

  Runs fibo.x, possibly using the MT simulator, and set program input
  variable N to an array of 1 element with value "10". If the
  simulator is used, add "-o NumProcessors=7" to the simulator command
  line.

Report bugs and patches to $bugreports.
EOF
  exit 0
}

do_version() {
  rev='$Rev$'
  rev=$(echo "$rev"|cut -d' ' -f2)
  cat <<EOF
slr $version (rev $slrev/$rev)

$copyright
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Raphael 'kena' Poss.
EOF
  exit 0
}

die() {
  printf '%s: %s\n' "$0" "$2" >&2
  exit $1
}

# Command line analysis
prev_arg=
show_embedded=
vars=
program=
query=
SIMARGS=${SIMARGS:-}
VERBOSE=${VERBOSE:-}
DEBUG=${DEBUG:-}
for arg in "$@"; do
  # if the previous option needs an argument, assign it
  if test -n "$prev_arg"; then
     eval "$prev_arg=\$arg"
     prev_arg=
     shift
     continue
  fi
  case $arg in
      -r)	prev_arg=runner; shift;;
      -c)	show_embedded=1; shift;;
      -x)       VERBOSE=1; shift;;
      -g)	VERBOSE=1; DEBUG=1; shift;;
      -v|--version)	do_version;;
      -h|--help)	do_usage;;
      -l|--list)  query=1; shift;;
      -Ws*)   lowarg=$(echo "$arg"|cut -d',' -f2-|tr ',' ' ')
	  SIMARGS="$SIMARGS $lowarg"
	  shift;;
      -d*=*) var=$(printf "%s" "$arg"|cut -c3-); vars="$vars $var"; shift;;
      -d*) var=$(printf "%s" "$arg"|cut -c3-); vars="$vars $var="; shift;;
      --)  break;;
      -*)  die 1 "unrecognized command-line argument: $arg (try -h)";;
      *=*) vars="$vars $arg"; shift ;;
      *)   if test -z "$program"; then program=$arg; shift
           else die 1 "unrecognized command-line argument: $arg (try -h)"
	   fi ;;
  esac
done


# does the program exist?
if ! test -f "$program"; then
  die 127 "no such file or directory: $program"
fi

# is it executable?
if ! test -x "$program"; then
  die 126 "permission denied: $program"
fi

if test -n "$show_embedded" -o -z "$runner"; then
  tag=$(strings "$program"|grep '^slr_runner:.*:'|tail -n1|cut -d: -f2)
  if test "x$tag" = "x"; then
    if test -n "$show_embedded"; then
       echo "(none found)"
       exit 0    
    fi
  else
    if test -n "$show_embedded"; then
       echo "$tag"
       exit 0    
    fi
  fi
fi

datatag=$(strings "$program"|grep '^slr_datatag:.*:'|tail -n1|cut -d: -f2)
if test "x$datatag" = "x"; then
    die 1 "can't determine cce tag to recompile"
fi


if test -z "$runner"; then
  # Not specified, use tag if found
  if test -n "$tag"; then
     runner=$tag
  else
     die 1 "can't determine runner (try -r)"
  fi
fi

# check it
runner_script=
saveIFS=$IFS
IFS=:
for l in $slc_libdir; do
  if test -r "$l/r-$runner/run.sh"; then
     runner_script=$l/r-$runner/run.sh
     break
  fi
done
if test -z "$runner_script"; then
    die 1 "$runner: cannot find runner script"
fi
IFS=$saveIFS

cleanfiles=
docleanup() {
    for f in $cleanfiles; do
	if test -z "$KEEP"; then
	    rm -rf "$f" >/dev/null 2>&1
	else
	    echo "$0: $f: left over temporary" >&2
	fi
    done
}

trapcleanup() {
    local sig
    sig=$1
    docleanup
    trap - INT PIPE TERM QUIT ALRM
    kill -$sig $$
}
errcleanup() {
    docleanup
    trap - ERR
    exit 1
}

trap 'trapcleanup INT' INT
trap 'trapcleanup PIPE' PIPE
trap 'trapcleanup TERM' TERM
trap 'trapcleanup QUIT' QUIT
trap 'trapcleanup ALRM' ALRM
trap 'errcleanup' ERR

# build temporary directory
baseout=$(basename "$program")
tmpdir=$(mktemp -d $TMPDIR/"$baseout".XXXXXXXX)
cleanfiles=$tmpdir

# check program parameters
strings "$program" | (grep '^slr_arg:'||true) >"$tmpdir"/args.spec
if test -n "$query"; then
  $python "$sag_helper" list <"$tmpdir"/args.spec
  exit 0
fi

if test -s "$tmpdir"/args.spec; then
    if test -n "$VERBOSE"; then
      echo "$0: running: $python $sag_helper $vars <$tmpdir/args.spec >$tmpdir/data.c" >&2
    fi
    $python "$sag_helper" $vars <"$tmpdir"/args.spec >"$tmpdir"/data.c

    found=
    saveIFS=$IFS
    IFS=:
    for d in $slc_datadir; do
	if test -r "$d/arggen.sl"; then
	    found=$d/arggen.sl
	    break
	fi
    done
    IFS=$saveIFS
    if test -z "$found"; then
	die 1 "arggen.sl not found in $slc_datadir"
    fi
    mkdir "$tmpdir"/slc-rec
    if test -n "$VERBOSE"; then
       echo "$0: running: TMPDIR=$tmpdir/slc-rec @BASH@ $slc_helper -b $datatag -o $tmpdir/gen.x -I$tmpdir $found" >&2
    fi
    TMPDIR="$tmpdir"/slc-rec @BASH@ "$slc_helper" -b "$datatag" -o "$tmpdir"/gen.x -I"$tmpdir" "$found"
    mkdir "$tmpdir"/slr-rec
    if test -n "$VERBOSE"; then
       echo "$0: running: TMPDIR=$tmpdir/slr-rec @BASH@ $0 $tmpdir/gen.x >$tmpdir/data 2>$tmpdir/gen.log" >&2
    fi
    TMPDIR="$tmpdir"/slr-rec @BASH@ "$0" "$tmpdir"/gen.x >"$tmpdir"/data 2>"$tmpdir"/gen.log
else
    touch "$tmpdir"/data
fi

#set +e
export SIMARGS VERBOSE DEBUG
if test -n "$VERBOSE"; then
   echo "$0: running: @BASH@ $runner_script $program $tmp/data" >&2
fi
@BASH@ "$runner_script" "$program" "$tmpdir"/data 
#set -e
docleanup
trap - ERR
#trap - ERR INT PIPE TERM QUIT ALRM
#if test $x -gt 128; then
#    kill -$(expr $x - 128) $$
#fi
#exit $x

