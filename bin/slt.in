#! @BASH@
# $Id$
#
copyright="Copyright (C) 2009 the CSA group - Universiteit van Amsterdam.."
#
# This program is free software: you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by   
# the Free Software Foundation; either version 2, or (at your option)    
# any later version.  
#   
# This program is distributed in the hope that it will be useful,   
# but WITHOUT ANY WARRANTY; without even the implied warranty of    
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     
# GNU General Public License for more details.    
#   
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA     
# 02110-1301, USA.    
set -e
basename=$(basename "$0")
root=$(cd $(dirname "$0"); pwd)

# Interface version number
version=2

slc=${SLC:-$root/slc}
runner=${SLR:-$root/slr}
timeout=$root/timeout

die() {
  echo "$0:" $@ >&2
  exit 2
}

usage() {
 cat <<EOF
SL Unit test and portability checker.

\`$basename' is a generic tester script for SL programs. It tries to
compile and execute the program given as input on multiple SVP
implementations, comparing results.

A test is considered to succeed when the following conditions are met:

- the program compiles and links successfully on all specified SVP
implementations, or it fails to compile on all implementations and
it is marked as not compilable (see below);

- the program runs successfully on all specified SVP implementations,
or the program fails to run on all implementations and it is marked
as not runnable (see below);

- on all runs but the first, the console output of the program is
identical to the output on the first run.

Usage: $0 [SOURCE] [IMPLEMENTATION]...

Options:

  -h, --help    Print this help.
  -v, --version Print a version number.


Multiple implementations can be specified, and each multiple
times. Implementations names are filtered through the \`cce' utility.

Example implementation aliases:

  seqc          sequential C scheduling

  ptl           muTC-ptl (pthreads / C++)

  ppp           "alternate" compiler for MT-Alpha

  utc0          Alpha-gcc compiler

  utcx          "desired muTC" (transform/preprocess only)

If no implementation is specified, or is set to "all", then the
implementations list above are tested, in that order.

The program performs the tests and display results as they become
available using the following format:

SOURCE     XXYZ XXYZ XXYZ ...

The first column contains the name of the SOURCE specified on the
command line. Each subsequent column contains a string of tests
results for the corresponding implementation specifier on the command
line.

Each string of test results has 3 sections:

1. compilation results; one of:

   L   An executable was produced successfully.

  8    A timeout occurred during compilation.

  !    A signal occurred during compilation.

  ?    Compilation succeeded, but a failure was expected.
 
  XT   Translation failed.

  XP   Preprocessing failed.

  XC   Compilation failed.

  XF   Post-compilation failed.

  XA   Assembly failed.

  XL   Linking failed.

  /T   Translation failed, as expected.

  /P   Preprocessing failed, as expected.

  /C   Compilation failed, as expected.

  /F   Post-compilation failed, as expected.

  /A   Assembly failed, as expected.

  /L   Linking failed, as expected.

2) execution results; a number of:

  R    Execution succeded without errors.

  8    A timeout occurred.

  !    A signal occurred.

  ?    Execution succeeded, but a failure was expected.

  o    A timeout occurred, as expected.

  .    A signal occurred, as expected.

  -    The program was not run.

3) check of reference output; one of:

  =   The output will be reused as reference.

  D   The output is identical to the reference.

  X   The output is different from the reference.

  -   The output was not checked.

To indicate expected failures, the source code can be annotated as
follows:

  XFAIL: pattern...     Indicate that an error or signal is expected
                        at the implementation/phase(s) matched by
                        the patterns (see below)

  XIGNORE: pattern...   Indicate that any result at the implementation/
                        phase(s) matched by the patterns should
                        be considered a success.

  XTIMEOUT: pattern...  Indicate that a timeout is expected 
                        at runtime in the implementation(s) matched by
			the patterns.

The annotation can appear anywhere; for example in source comments.

Patterns have the following form: IMPL:PHASESPEC. Where: IMPL is a
pattern that matches the implementation name being tested; PHASESPEC
matches the phase(s) being tested. The pattern matches when at a test
point both the current implementation and the current phase match the
pattern. Example patterns:

  *x:*                  Match any phase in any implementation ending 
                        with "x". 

  ptl*:D                Ignore the program output for implementations
                        whose name start with "ptl".

To run the program the helper script \`slr' is used. By default, a
single run is performed without extra arguments to \`slr'. When extra
arguments are required, the program should contains annotations of the
following form, one per (commented) line:

  SLT_RUN: args...

For each occurrence of SLT_RUN in the program source code, \`slr' is
run once with the arguments specified after SLT_RUN. There are as many
"execution" columns in the output as there are SLT_RUN specifiers in
the program. For example:

  SLT_RUN: N=5 -Ws,-o -Ws,NumProcessors=1
  SLT_RUN: N=10

For program output comparison, the test assumes that the first
implementation tested produces the reference output; subsequent
implementations are checked against the results of the first run.

During testing a number of intermediate files are generated. If the
SOURCE file is named test.sl, the following files are generated:

  IMPL/test.log         Test log

  IMPL/test.{c,cc,utc}  Source code after transformation

  IMPL/test.{i,ii,ui}   Source code after preprocessing

  IMPL/test.s0          Raw assembly output

  IMPL/test.s           Assembly output

  IMPL/test.o           Object file

  IMPL/test.x           Executable

  IMPL/test.out         Output during execution

If a test is successful the corresponding files are erased after the
test completes, unless the environment variable KEEP is set and
non-empty.

Environment variables:
  SLC            Location of the SL compiler. Default is 
                 "slc" in the same directory as \`$basename'.

  SLR            Location of the SL runner. Default is 
                 "slr" in the same directory as \`$basename'.

  KEEP           If set, do not erase intermediary files when a test
                 succeeds. Default is not set.

  TEST_HERE      If set and not empty, use a subdirectory in the current
                 directory for each implementation instead of a
                 subdirectory in the program's source directory.

  TEXT_ONLY      If set and not empty, use plain text messages instead
                 of colored/positioned characters on the console.

  XIGNORE        If set and not empty, prepend to the XIGNORE pattern
                 list set by programs. Can be used to mark specific
                 implementations as not relevant for overall test results.
                 Default is "XIGNORE=*x:*"

Diagnostics:
  0              The test succeeded.

  1              The test failed.

  2              Invalid test parameters.

Report bugs and suggestions to the CSA issue tracker.
EOF
   exit 0 
}


if test "$1" = "--help" -o "$1" = "-h"; then
  usage
  exit 0
elif test "$1" = "--version" -o "$1" = "-v"; then
  rev='$Rev$'
  rev=$(echo "$rev"|cut -d' ' -f2)
  cat <<EOF
$basename $version.$rev

$copyright
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Raphael 'kena' Poss.
EOF
  exit 0
fi

# Sanity check: verify that dependencies are there.
test_exec() {
  if ! test -x "$1"; then
     die "$1: not found or not executable"
  fi
}
test_exec "$slc"
test_exec "$runner"
test_exec "$timeout"

# Compute base name and directory of test source.
testdir=$(dirname "$1")
testsrc=$1

case $1 in
  *.sl)     testname=$(basename "$1" .sl);;
  *.s)      testname=$(basename "$1" .s);;
  *)
  cat <<EOF
Usage: $basename [SOURCE] [IMPLEMENTATION]...
   or: $basename -h
EOF
   exit 2
esac

shift

case $1 in
  ""|all)
    impl1=seqc
    set ptl ppp utc0 utcx
    ;;
  *)
    impl1=$1
    shift
    ;;
esac

if test ! -r $testsrc; then
   die "$testsrc: cannot read file" 
fi

check_status() {
    status=ok
    if test $1 = 127; then status=invcmd
    elif test $1 = 0; then status=ok
    elif test $1 -lt 127; then status=error; errcode=$1
    elif test $1 = 137; then status=timeout
    else status=signal; signal=$(expr $1 - 128)
    fi
    if test $status = signal; then echo "Terminated with signal $signal" >&2; fi
    if test $status = error; then echo "Terminated with status code $errcode" >&2; fi

    # Bailout if invalid command or command was interrupted (SIGINT = 2).
    if test $status = invcmd || test $status = signal -a "$signal" = 2; then exit $1; fi
}

place_chars() {
  local offset color chars str nicemsg
  offset=$1
  color=$2
  chars=$3
  if test -n "$TEXT_ONLY"; then
      case $color in
	  32) nicemsg=good ;;
	  33) nicemsg=xfail ;;
	  31) nicemsg=bad ;;
	  37) nicemsg=skip ;;
	  *) nicemsg="???" ;;
      esac
      echo "$testsrc: $outdir: $impl1: $chars ($nicemsg)"
  else
      str=$(printf '\r\033[%sC\033[%sm%s\e[0m' $offset $color "$chars")
      printf "%s" "$str"
  fi
}

matchpat() {
  local pats pat a found
  pats=$1
  shift
  set -f
  found=
  for pat in $pats; do
    for a in "$@"; do
      if [[ "$impl:$a" == $pat ]]; then
        found=1
        break 2
      fi
    done
  done
  set +f
  if test -z "$found"; then return 1; fi
  return 0
}

xign() {
    matchpat "$ignpats" "$@"
}

xfail() {
    matchpat "$xfailpats" "$@"
}

xto() {
    matchpat "$xtopats" "$@"
}

report_compile() {
  local code offset color char str outlog found pat
  code=$1
  offset=$2
  outlog=$3
  check_status "$code" 2>>"$outlog"
  fail=0
  dorun=1
  case $status in
      signal)  color=31; char="! "; fail=1 ;;
      timeout) color=31; char="8 "; fail=1 ;; 
      ok)      
	  if xfail T P C F A L
          then color=31; char="? "; fail=1 
    	  else color=32; char=" L"
	  fi ;;
    error) 
       case $errcode in
          1) color=31; char="X "; fail=1 ;;
          2) if xfail T; then color=33; char="/T"; else color=31; char="XT"; fail=1; fi;;
          3) if xfail P; then color=33; char="/P"; else color=31; char="XP"; fail=1; fi;;
          4) if xfail C; then color=33; char="/C"; else color=31; char="XC"; fail=1; fi;;
          5) if xfail F; then color=33; char="/F"; else color=31; char="XF"; fail=1; fi;;
          6) if xfail A; then color=33; char="/A"; else color=31; char="XA"; fail=1; fi;;
          7) if xfail L; then color=33; char="/L"; else color=31; char="XL"; fail=1; fi;;
          *) color=31; char="??"; fail=1 ;;
       esac
       dorun=0
  esac
  
  if xign T P C F A L; then color=37; fail=0; dorun=0; fi

  if test $fail = 1; then
    dorun=0
  fi
  place_chars $offset $color "$char"
}

report_run() {
  local code offset outlog color char str
  code=$1
  offset=$2
  outlog=$3
  check_status "$code" 2>>"$outlog"
  refail=0
  dodiff=1
  case $status in
    signal)  dodiff=0; 
             if xfail R; then color=33; char="."; else color=31; char="!"; refail=1; fi;;
    timeout) dodiff=0; 
             if xto R; then color=33; char="o"; else color=31; char="8"; refail=1; fi;;
    ok)      if xfail R; then color=31; char="?"; refail=1; else color=32; char="R"; fi ;;
    error)   dodiff=0;
             if xfail R; then color=33; char="/"; else color=31; char="X"; refail=1; fi;;
  esac
  if xign R; then refail=0; dodiff=0; color=37; fi
  if test $refail = 1; then fail=1; fi
  place_chars $offset $color "$char"
}

do_compile() {
  local offset command x
  offset=$1
  echo "===== TEST: $testsrc, COMPILE ======" >$baseout.log
  command="$timeout $slc -v -t $outdir -b $impl -o $baseout.x $testsrc"
  echo "$command" >>$baseout.log
  set +e
  KEEP=1 TIMEOUT=40 $command >>$baseout.log 2>&1
  x=$?
  set -e

  report_compile $x $offset $baseout.log
}

do_run() {
  local offset command x i
  local -a vars
  offset=$1

  dodiff=1
  if test $dorun = 0; then
    echo "Not running program." >>$baseout.log
    for ((i=0; i<$nruns; ++i)); do place_chars $(($offset + $i)) 37 "-"; done
    dodiff=0
  else
      printf '' >$baseout.out
      while read -a vars ; do
	  echo "===== RUNNING PROGRAM: ${vars[*]} =====" >>$baseout.log
	  command="$timeout $runner $baseout.x ${vars[*]}"
	  echo "$command >>$baseout.out" >>$baseout.log
	  set +e
	  $command >>$baseout.out 2>>$baseout.log 
	  x=$?
	  set -e
	  
	  report_run $x $offset $baseout.log
	  offset=$(expr $offset + 1)
      done <"$runspec"
  fi
}

do_diff() {
  local offset refout str diffok
  offset=$1
  refout=$2

  if test $fail = 1 -o $dorun = 0 -o $dodiff = 0; then
    echo "Not testing output." >>$baseout.log
    place_chars $offset 37 "-"
  else
      echo "===== CHECKING OUTPUT =====" >>$baseout.log
      echo "diff -u $refout $baseout.out" >>$baseout.log
      if diff -u "$refout" "$baseout.out" >>"$baseout.log" 2>&1; then
	  echo "Output identical to reference" >>$baseout.log
	  if xfail D; then char=?; color=31; fail=1; else char=D; color=32; fi
      else
	  if xfail D; then char="/"; color=33; else char=X; color=31; fail=1; fi
      fi
      if xign D; then color=37; fail=0; fi
      place_chars $offset $color $char
  fi
}

do_check() {
  local offset refout compref b
  impl=$1
  offset=$2
  refout=$3

  do_compile $offset
  offset=$(expr $offset + 2)
  do_run $offset
  offset=$(expr $offset + $nruns)
  if test -n "$refout"; then
      do_diff $offset "$refout"
  else
      if test $dodiff = 0; then
	  place_chars $offset 37 "-"
      else
	  place_chars $offset 32 "="
      fi
  fi
  if test $fail = 0 -a -z "$KEEP"; then
    if test "x$refout" = "x"; then
      compref=$baseout.out
    else
      compref=$refout
    fi
    for b in "$baseout"*; do
       if test "x$compref" != "x$b" -a "x$runspec" != "x$b"; then
          rm -rf "$b"
       fi
    done
    rmdir "$outdir" >/dev/null 2>&1 || true
  fi
  return $fail
}

do_preptest() {
    local vars save vn var val prefign
    impl=$(echo "$1" | cut -d: -f1)
    vars=$(echo "$1" | cut -d: -f2-)
    if test -n "$vars"; then
	save=$IFS
	IFS=":"
	for vn in $vars; do
	    var=$(echo "$vn"|cut -d= -f1)
	    val=$(echo "$vn"|cut -d= -f2-|sed -e s/\'/\'\"\'\"\'/g)
	    eval "export $var='$val'"
	done
	IFS=$save
    fi
    
    outdir=$testdir/_$counter
    counter=$(expr $counter + 1)
    if test -n "$TEST_HERE"; then
	outdir=$(echo "_$outdir"|tr '/.:' '___')
    fi
    baseout=$outdir/$testname
    
    if ! mkdir -p "$outdir" >/dev/null 2>&1; then
	die "$outdir: cannot create directory" 
    fi
    
    if ! test -w "$outdir"; then
	die "$outdir: directory is not writable"
    fi
    rm -rf "$baseout"*
    export TMPDIR="$outdir"
}


# start testing
counter=0
do_preptest "$impl1"

prefign=${XIGNORE:-*x:*}
xfailpats=$(grep "XFAIL:" <"$testsrc"|sed -e 's/^.*XFAIL:\(.*\)$/\1/g')
ignpats=$(echo "$prefign"; grep "XIGNORE:" <"$testsrc"|sed -e 's/^.*XIGNORE:\(.*\)$/\1/g')
xtopats=$(grep "XTIMEOUT:" <"$testsrc"|sed -e 's/^.*XTIMEOUT:\(.*\)$/\1/g')

(grep "SLT_RUN:" <"$testsrc"|sed -e 's/^.*SLT_RUN:\(.*\)$/\1/g') >"$baseout".runspec
nruns=$(wc -l <"$baseout".runspec)
if test $nruns = 0; then
    echo >"$baseout".runspec
    nruns=1
fi
runspec="$baseout".runspec

if test -z "$TEXT_ONLY"; then
    # find terminal width and squeeze first
    # column as needed
    colspertest=$(expr $nruns + 4)
    if stty size >/dev/null 2>&1; then
	COLUMNS=$(stty size|cut -d' ' -f2)
    fi
    COLUMNS=${COLUMNS:-80}
    nrimpl=$#
    nrcols=$(expr \( $nrimpl + 1 \) \* $colspertest )
    remainder=$(expr $COLUMNS - $nrcols - 5)
    if test $remainder -lt 20; then remainder=20; fi
    name=$testsrc
    namelen=$(echo "$name"|wc -c)
    if test $namelen -gt $remainder; then
	name=$(echo "$name"|sed -e 's,\([0-9]_\)[^/]*,\1*,g')
	namelen=$(echo "$name"|wc -c)
	rem=$(expr $remainder - 3)
	if test $namelen -gt $rem; then
	    name=$(echo "$name"|sed -e 's/^.*\(.\{'$rem'\}\)$/...\1/g')
	fi
    fi
    printf "%-${remainder}s" "$name"
fi

bye() {
  local sig
  sig=$1
  for pid in $towait; do
    kill $pid >/dev/null 2>&1
  done
  signalled=$sig
}

check_proc() {
    local x
    x=$1
    if test -n "$signalled"; then 
        echo >&2
	echo "Signal received (SIG$signalled)!" >&2
	trap - INT QUIT HUP TERM PIPE
        kill -$signalled $$
	exit 128
    elif test $x != 0; then
	fail=1
    fi
}

offset=${remainder:-0}
fail=0
# Start with first impl, need to wait for it
# since output will be used as reference:

signalled=
trap "bye INT" INT
trap "bye QUIT" QUIT
trap "bye HUP" HUP
trap "bye TERM" TERM
trap "bye PIPE" PIPE
do_check $impl $offset &
towait=$!
set +e
wait $towait
x=$?
set -e
check_proc $x

# Perform other tests asynchronously
towait=
refout=$baseout.out
for impl1 in "$@"; do
    offset=$(expr $offset + $colspertest)
    do_preptest "$impl1"
    do_check $impl $offset "$refout" &
    towait="$towait $!"
done

# After they are started, wait on them
for w in $towait; do
    set +e
    wait $w
    x=$?
    set -e
    check_proc $x
done

if test -z "$TEXT_ONLY"; then
    offset=$(expr $offset + $colspertest)
    if test $fail = 0; then
	place_chars $offset 37 "\o/"
    else
	place_chars $offset 31 ":("
    fi
    echo
else
    if test $fail = 0; then
	echo "$testsrc: test(s) succeeded."
    else
	echo "$testsrc: test(s) failed."
    fi
fi

if test $fail = 0 -a -z "$KEEP"; then
    rm -f "$refout" "$runspec"
    rmdir $(dirname "$refout") >/dev/null 2>&1 || true
fi
exit $fail

# -*- mode: shell -*-
